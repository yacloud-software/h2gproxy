// Code generated by protoc-gen-go.
// source: protos/golang.conradwood.net/apis/h2gproxy/h2gproxy.proto
// DO NOT EDIT!

/*
Package h2gproxy is a generated protocol buffer package.

It is generated from these files:
	protos/golang.conradwood.net/apis/h2gproxy/h2gproxy.proto

It has these top-level messages:
	CreateConfigRequest
	CreateConfigResponse
	ApplyConfigRequest
	ApplyConfigResponse
	AddConfigResponse
	AddConfigTCPRequest
	Header
	Parameter
	StreamDataResponse
	StreamRequest
	StreamResponse
	StreamDataRequest
	ServeRequest
	Cookie
	ServeResponse
	Config
	AddConfigHTTPRequest
	HostListEntry
	HostList
	BodyData
	ConfigureProberRequest
	TCPSession
	TCPSessionList
	TCPMetaRequest
*/
package h2gproxy

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CreateConfigRequest struct {
}

func (m *CreateConfigRequest) Reset()                    { *m = CreateConfigRequest{} }
func (m *CreateConfigRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateConfigRequest) ProtoMessage()               {}
func (*CreateConfigRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type CreateConfigResponse struct {
	ConfigID string `protobuf:"bytes,1,opt,name=ConfigID" json:"ConfigID,omitempty"`
}

func (m *CreateConfigResponse) Reset()                    { *m = CreateConfigResponse{} }
func (m *CreateConfigResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateConfigResponse) ProtoMessage()               {}
func (*CreateConfigResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *CreateConfigResponse) GetConfigID() string {
	if m != nil {
		return m.ConfigID
	}
	return ""
}

type ApplyConfigRequest struct {
	ConfigID string `protobuf:"bytes,1,opt,name=ConfigID" json:"ConfigID,omitempty"`
}

func (m *ApplyConfigRequest) Reset()                    { *m = ApplyConfigRequest{} }
func (m *ApplyConfigRequest) String() string            { return proto.CompactTextString(m) }
func (*ApplyConfigRequest) ProtoMessage()               {}
func (*ApplyConfigRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ApplyConfigRequest) GetConfigID() string {
	if m != nil {
		return m.ConfigID
	}
	return ""
}

type ApplyConfigResponse struct {
	Applied bool `protobuf:"varint,1,opt,name=Applied" json:"Applied,omitempty"`
}

func (m *ApplyConfigResponse) Reset()                    { *m = ApplyConfigResponse{} }
func (m *ApplyConfigResponse) String() string            { return proto.CompactTextString(m) }
func (*ApplyConfigResponse) ProtoMessage()               {}
func (*ApplyConfigResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ApplyConfigResponse) GetApplied() bool {
	if m != nil {
		return m.Applied
	}
	return false
}

type AddConfigResponse struct {
}

func (m *AddConfigResponse) Reset()                    { *m = AddConfigResponse{} }
func (m *AddConfigResponse) String() string            { return proto.CompactTextString(m) }
func (*AddConfigResponse) ProtoMessage()               {}
func (*AddConfigResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type AddConfigTCPRequest struct {
	ConfigID          string `protobuf:"bytes,1,opt,name=ConfigID" json:"ConfigID,omitempty"`
	SourcePort        int32  `protobuf:"varint,2,opt,name=SourcePort" json:"SourcePort,omitempty"`
	TargetServicePath string `protobuf:"bytes,3,opt,name=TargetServicePath" json:"TargetServicePath,omitempty"`
	KeepAliveSeconds  uint32 `protobuf:"varint,4,opt,name=KeepAliveSeconds" json:"KeepAliveSeconds,omitempty"`
}

func (m *AddConfigTCPRequest) Reset()                    { *m = AddConfigTCPRequest{} }
func (m *AddConfigTCPRequest) String() string            { return proto.CompactTextString(m) }
func (*AddConfigTCPRequest) ProtoMessage()               {}
func (*AddConfigTCPRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *AddConfigTCPRequest) GetConfigID() string {
	if m != nil {
		return m.ConfigID
	}
	return ""
}

func (m *AddConfigTCPRequest) GetSourcePort() int32 {
	if m != nil {
		return m.SourcePort
	}
	return 0
}

func (m *AddConfigTCPRequest) GetTargetServicePath() string {
	if m != nil {
		return m.TargetServicePath
	}
	return ""
}

func (m *AddConfigTCPRequest) GetKeepAliveSeconds() uint32 {
	if m != nil {
		return m.KeepAliveSeconds
	}
	return 0
}

// ******************************************************
// gRPC Proxies must serve this
// ******************************************************
type Header struct {
	Name   string   `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Values []string `protobuf:"bytes,2,rep,name=Values" json:"Values,omitempty"`
}

func (m *Header) Reset()                    { *m = Header{} }
func (m *Header) String() string            { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()               {}
func (*Header) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Header) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Header) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

type Parameter struct {
	Name  string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=Value" json:"Value,omitempty"`
}

func (m *Parameter) Reset()                    { *m = Parameter{} }
func (m *Parameter) String() string            { return proto.CompactTextString(m) }
func (*Parameter) ProtoMessage()               {}
func (*Parameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Parameter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Parameter) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type StreamDataResponse struct {
	Response *StreamResponse `protobuf:"bytes,1,opt,name=Response" json:"Response,omitempty"`
	Data     []byte          `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *StreamDataResponse) Reset()                    { *m = StreamDataResponse{} }
func (m *StreamDataResponse) String() string            { return proto.CompactTextString(m) }
func (*StreamDataResponse) ProtoMessage()               {}
func (*StreamDataResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *StreamDataResponse) GetResponse() *StreamResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *StreamDataResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// stream backends receive this from h2gproxy
type StreamRequest struct {
	Headers    []*Header    `protobuf:"bytes,1,rep,name=Headers" json:"Headers,omitempty"`
	Path       string       `protobuf:"bytes,3,opt,name=Path" json:"Path,omitempty"`
	Method     string       `protobuf:"bytes,4,opt,name=Method" json:"Method,omitempty"`
	Parameters []*Parameter `protobuf:"bytes,5,rep,name=Parameters" json:"Parameters,omitempty"`
	Host       string       `protobuf:"bytes,6,opt,name=Host" json:"Host,omitempty"`
	UserAgent  string       `protobuf:"bytes,7,opt,name=UserAgent" json:"UserAgent,omitempty"`
	SourceIP   string       `protobuf:"bytes,8,opt,name=SourceIP" json:"SourceIP,omitempty"`
	Query      string       `protobuf:"bytes,9,opt,name=Query" json:"Query,omitempty"`
	Port       uint32       `protobuf:"varint,10,opt,name=Port" json:"Port,omitempty"`
}

func (m *StreamRequest) Reset()                    { *m = StreamRequest{} }
func (m *StreamRequest) String() string            { return proto.CompactTextString(m) }
func (*StreamRequest) ProtoMessage()               {}
func (*StreamRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *StreamRequest) GetHeaders() []*Header {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *StreamRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *StreamRequest) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *StreamRequest) GetParameters() []*Parameter {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *StreamRequest) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *StreamRequest) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

func (m *StreamRequest) GetSourceIP() string {
	if m != nil {
		return m.SourceIP
	}
	return ""
}

func (m *StreamRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *StreamRequest) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// stream backends send this to H2GProxy
type StreamResponse struct {
	Filename     string            `protobuf:"bytes,1,opt,name=Filename" json:"Filename,omitempty"`
	Size         uint64            `protobuf:"varint,2,opt,name=Size" json:"Size,omitempty"`
	MimeType     string            `protobuf:"bytes,3,opt,name=MimeType" json:"MimeType,omitempty"`
	ExtraHeaders map[string]string `protobuf:"bytes,4,rep,name=ExtraHeaders" json:"ExtraHeaders,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	StatusCode   uint32            `protobuf:"varint,5,opt,name=StatusCode" json:"StatusCode,omitempty"`
}

func (m *StreamResponse) Reset()                    { *m = StreamResponse{} }
func (m *StreamResponse) String() string            { return proto.CompactTextString(m) }
func (*StreamResponse) ProtoMessage()               {}
func (*StreamResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *StreamResponse) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *StreamResponse) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *StreamResponse) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *StreamResponse) GetExtraHeaders() map[string]string {
	if m != nil {
		return m.ExtraHeaders
	}
	return nil
}

func (m *StreamResponse) GetStatusCode() uint32 {
	if m != nil {
		return m.StatusCode
	}
	return 0
}

type StreamDataRequest struct {
	Request *StreamRequest `protobuf:"bytes,1,opt,name=Request" json:"Request,omitempty"`
	Data    []byte         `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *StreamDataRequest) Reset()                    { *m = StreamDataRequest{} }
func (m *StreamDataRequest) String() string            { return proto.CompactTextString(m) }
func (*StreamDataRequest) ProtoMessage()               {}
func (*StreamDataRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *StreamDataRequest) GetRequest() *StreamRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *StreamDataRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// unary backends receive this from h2gproxy
type ServeRequest struct {
	Headers      []*Header    `protobuf:"bytes,1,rep,name=Headers" json:"Headers,omitempty"`
	Body         string       `protobuf:"bytes,2,opt,name=Body" json:"Body,omitempty"`
	Path         string       `protobuf:"bytes,3,opt,name=Path" json:"Path,omitempty"`
	Method       string       `protobuf:"bytes,4,opt,name=Method" json:"Method,omitempty"`
	Parameters   []*Parameter `protobuf:"bytes,5,rep,name=Parameters" json:"Parameters,omitempty"`
	Host         string       `protobuf:"bytes,6,opt,name=Host" json:"Host,omitempty"`
	UserAgent    string       `protobuf:"bytes,7,opt,name=UserAgent" json:"UserAgent,omitempty"`
	SourceIP     string       `protobuf:"bytes,8,opt,name=SourceIP" json:"SourceIP,omitempty"`
	SessionToken string       `protobuf:"bytes,9,opt,name=SessionToken" json:"SessionToken,omitempty"`
}

func (m *ServeRequest) Reset()                    { *m = ServeRequest{} }
func (m *ServeRequest) String() string            { return proto.CompactTextString(m) }
func (*ServeRequest) ProtoMessage()               {}
func (*ServeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ServeRequest) GetHeaders() []*Header {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *ServeRequest) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func (m *ServeRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *ServeRequest) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *ServeRequest) GetParameters() []*Parameter {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *ServeRequest) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *ServeRequest) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

func (m *ServeRequest) GetSourceIP() string {
	if m != nil {
		return m.SourceIP
	}
	return ""
}

func (m *ServeRequest) GetSessionToken() string {
	if m != nil {
		return m.SessionToken
	}
	return ""
}

type Cookie struct {
	Name   string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Value  string `protobuf:"bytes,2,opt,name=Value" json:"Value,omitempty"`
	Expiry uint32 `protobuf:"varint,3,opt,name=Expiry" json:"Expiry,omitempty"`
}

func (m *Cookie) Reset()                    { *m = Cookie{} }
func (m *Cookie) String() string            { return proto.CompactTextString(m) }
func (*Cookie) ProtoMessage()               {}
func (*Cookie) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Cookie) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Cookie) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Cookie) GetExpiry() uint32 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

type ServeResponse struct {
	HTTPResponseCode uint32 `protobuf:"varint,1,opt,name=HTTPResponseCode" json:"HTTPResponseCode,omitempty"`
	GRPCCode         uint32 `protobuf:"varint,2,opt,name=GRPCCode" json:"GRPCCode,omitempty"`
	//  string OBSOLETE_Text = 3;    // Deprecated!! the response to be served to the client
	MimeType        string    `protobuf:"bytes,4,opt,name=MimeType" json:"MimeType,omitempty"`
	Cookies         []*Cookie `protobuf:"bytes,5,rep,name=Cookies" json:"Cookies,omitempty"`
	Body            []byte    `protobuf:"bytes,6,opt,name=Body,proto3" json:"Body,omitempty"`
	RedirectToSlash bool      `protobuf:"varint,7,opt,name=RedirectToSlash" json:"RedirectToSlash,omitempty"`
}

func (m *ServeResponse) Reset()                    { *m = ServeResponse{} }
func (m *ServeResponse) String() string            { return proto.CompactTextString(m) }
func (*ServeResponse) ProtoMessage()               {}
func (*ServeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *ServeResponse) GetHTTPResponseCode() uint32 {
	if m != nil {
		return m.HTTPResponseCode
	}
	return 0
}

func (m *ServeResponse) GetGRPCCode() uint32 {
	if m != nil {
		return m.GRPCCode
	}
	return 0
}

func (m *ServeResponse) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *ServeResponse) GetCookies() []*Cookie {
	if m != nil {
		return m.Cookies
	}
	return nil
}

func (m *ServeResponse) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *ServeResponse) GetRedirectToSlash() bool {
	if m != nil {
		return m.RedirectToSlash
	}
	return false
}

type Config struct {
	Config []*AddConfigHTTPRequest `protobuf:"bytes,1,rep,name=Config" json:"Config,omitempty"`
}

func (m *Config) Reset()                    { *m = Config{} }
func (m *Config) String() string            { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()               {}
func (*Config) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *Config) GetConfig() []*AddConfigHTTPRequest {
	if m != nil {
		return m.Config
	}
	return nil
}

//
// A configuration of an http endpoint
type AddConfigHTTPRequest struct {
	ConfigID string `protobuf:"bytes,1,opt,name=ConfigID" json:"ConfigID,omitempty"`
	// the url snippet to match on
	URLPath string `protobuf:"bytes,2,opt,name=URLPath" json:"URLPath,omitempty"`
	// (we need either target or service)
	// the optional url to forward to
	TargetHost string `protobuf:"bytes,3,opt,name=TargetHost" json:"TargetHost,omitempty"`
	TargetPort int32  `protobuf:"varint,4,opt,name=TargetPort" json:"TargetPort,omitempty"`
	// the service address to forward to
	TargetService string `protobuf:"bytes,5,opt,name=TargetService" json:"TargetService,omitempty"`
	// we might need to rewrite the URL a bit to match what the target expects
	TargetURL string `protobuf:"bytes,6,opt,name=TargetURL" json:"TargetURL,omitempty"`
	// me might need to set a specific host header to get what we want
	TargetHostname string `protobuf:"bytes,7,opt,name=TargetHostname" json:"TargetHostname,omitempty"`
	// we strip the urlpath out of the request before
	// passing it to the backend
	// we optionally may insert this prefix
	PathPrefix string `protobuf:"bytes,8,opt,name=PathPrefix" json:"PathPrefix,omitempty"`
	// and we might need random stupid headers
	Header []string `protobuf:"bytes,9,rep,name=Header" json:"Header,omitempty"`
	// if true, proxy will enforce authentication
	// before proxying to the target
	NeedAuth bool `protobuf:"varint,10,opt,name=NeedAuth" json:"NeedAuth,omitempty"`
	// for this entry to match, user must be in any of these groups
	// if empty - any AUTHENTICATED request matches
	Groups []string `protobuf:"bytes,11,rep,name=Groups" json:"Groups,omitempty"`
	// same as groups, but for users :)
	Users []string `protobuf:"bytes,12,rep,name=Users" json:"Users,omitempty"`
	// if empty will match all hosts
	URLHostname string `protobuf:"bytes,13,opt,name=URLHostname" json:"URLHostname,omitempty"`
	// either "ip" or "hostname"(default)
	ForwardedFor string `protobuf:"bytes,14,opt,name=ForwardedFor" json:"ForwardedFor,omitempty"`
	// if non-nil 500 errors will be intercepted and a webpage served instead
	ErrorPage500 string `protobuf:"bytes,15,opt,name=ErrorPage500" json:"ErrorPage500,omitempty"`
	// if non-nil 400 errors will be intercepted and a webpage served instead
	ErrorPage400 string `protobuf:"bytes,16,opt,name=ErrorPage400" json:"ErrorPage400,omitempty"`
	// send a "fake" Authorization header to the backend? (e.g. gerrit needs this)
	// an "Authorization:" header will be added to each request to the backend, encoding
	// either the userid or the username (see UseUserNameForFakeAuth)
	SendFakeAuthorization bool `protobuf:"varint,17,opt,name=SendFakeAuthorization" json:"SendFakeAuthorization,omitempty"`
	// if nil, it'll set the original host as requested by the client. override if
	// necessary
	// special: set it to "targethost" and it will be set to whatever targethost
	// matched
	ForwardedHost string `protobuf:"bytes,18,opt,name=ForwardedHost" json:"ForwardedHost,omitempty"`
	// a name made up to identify this entry by humans
	// e.g. for statistics and/or debugging
	ConfigName string `protobuf:"bytes,19,opt,name=ConfigName" json:"ConfigName,omitempty"`
	// if empty - matches any protocol
	// otherwise http/https
	ProtocolRequired string `protobuf:"bytes,20,opt,name=ProtocolRequired" json:"ProtocolRequired,omitempty"`
	// allow authorization headers to be passed to the backend (e.g. hes needs
	// this)
	// this is potentially a very dangerous option - enable with caution
	AllowAuthorizationFromClient bool `protobuf:"varint,21,opt,name=AllowAuthorizationFromClient" json:"AllowAuthorizationFromClient,omitempty"`
	// another dangerous option: enable basic auth from the backend,
	// bypassing SSO altogether. Use with caution!
	ForceBackendAuthorization bool `protobuf:"varint,22,opt,name=ForceBackendAuthorization" json:"ForceBackendAuthorization,omitempty"`
	// max requests "in flights" (== currently processing) for
	// this backend (total over all instances)
	// additional requests past this limit are dropped with error
	MaxInFlights int32 `protobuf:"varint,23,opt,name=MaxInFlights" json:"MaxInFlights,omitempty"`
	//
	// if 0 h2gproxy will forward http requests to http-only backends (no grpc)<br/>
	// if 1 h2gproxy will parse the form and forward via grpc to json-api-multiplexer backend<br/>
	// if 2 h2gproxy will parse the form and forward via grpc to htmlserver backend<br/>
	// if 3 h2gproxy will parse the form and forward via grpc to weblogin backend<br/>
	// if 4 h2gproxy will forward to (any specified) streaming grpc api backend<br/>
	// if 5 h2gproxy will forward to (any specified) streaming grpc proxying api backend with raw http information. An entry of this type will match if URLHostname matches partially. Security risk (see readme!)<br/>
	Api uint32 `protobuf:"varint,24,opt,name=Api" json:"Api,omitempty"`
	// if true h2gproxy will intercept Redirect (301) from backends and rewrite them
	// to match what the client sent (mainly for the many broken web frameworks out there)
	RewriteRedirectHost bool `protobuf:"varint,25,opt,name=RewriteRedirectHost" json:"RewriteRedirectHost,omitempty"`
	// choose between ["id"/"email"/"abbrev"] with FakeBackendAuthorization
	UserNameForFakeAuth string `protobuf:"bytes,26,opt,name=UserNameForFakeAuth" json:"UserNameForFakeAuth,omitempty"`
	// max amount of requests per second
	MaxPerSec uint32 `protobuf:"varint,27,opt,name=MaxPerSec" json:"MaxPerSec,omitempty"`
	// this will only match if request comes from private ip
	RFC1918Only bool `protobuf:"varint,28,opt,name=RFC1918Only" json:"RFC1918Only,omitempty"`
	// normally, if we have a valid certificate for a hostname which
	// a client requests via http, then we will automatically send a
	// redirect to the corresponding https location
	// with this option set to true we will serve the content over http
	// instead
	AcceptHTTP bool `protobuf:"varint,29,opt,name=AcceptHTTP" json:"AcceptHTTP,omitempty"`
	// if we proxy a host (targethost), we normally use http (unless it's on port 443)
	// this option will make it use https instead
	ProxyForHTTPS bool `protobuf:"varint,30,opt,name=ProxyForHTTPS" json:"ProxyForHTTPS,omitempty"`
	// how many seconds might this request run before timingout (context deadline)
	MaxDuration uint32 `protobuf:"varint,31,opt,name=MaxDuration" json:"MaxDuration,omitempty"`
	// for certain configurations, such as apis or proxies we might only want to do basic auth or tokens or
	DisableFormBasedAuth        bool `protobuf:"varint,32,opt,name=DisableFormBasedAuth" json:"DisableFormBasedAuth,omitempty"`
	LowLatency                  bool `protobuf:"varint,33,opt,name=LowLatency" json:"LowLatency,omitempty"`
	WebBackendAuthenticatesOnly bool `protobuf:"varint,34,opt,name=WebBackendAuthenticatesOnly" json:"WebBackendAuthenticatesOnly,omitempty"`
}

func (m *AddConfigHTTPRequest) Reset()                    { *m = AddConfigHTTPRequest{} }
func (m *AddConfigHTTPRequest) String() string            { return proto.CompactTextString(m) }
func (*AddConfigHTTPRequest) ProtoMessage()               {}
func (*AddConfigHTTPRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *AddConfigHTTPRequest) GetConfigID() string {
	if m != nil {
		return m.ConfigID
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetURLPath() string {
	if m != nil {
		return m.URLPath
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetTargetHost() string {
	if m != nil {
		return m.TargetHost
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetTargetPort() int32 {
	if m != nil {
		return m.TargetPort
	}
	return 0
}

func (m *AddConfigHTTPRequest) GetTargetService() string {
	if m != nil {
		return m.TargetService
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetTargetURL() string {
	if m != nil {
		return m.TargetURL
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetTargetHostname() string {
	if m != nil {
		return m.TargetHostname
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetPathPrefix() string {
	if m != nil {
		return m.PathPrefix
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetHeader() []string {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *AddConfigHTTPRequest) GetNeedAuth() bool {
	if m != nil {
		return m.NeedAuth
	}
	return false
}

func (m *AddConfigHTTPRequest) GetGroups() []string {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *AddConfigHTTPRequest) GetUsers() []string {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *AddConfigHTTPRequest) GetURLHostname() string {
	if m != nil {
		return m.URLHostname
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetForwardedFor() string {
	if m != nil {
		return m.ForwardedFor
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetErrorPage500() string {
	if m != nil {
		return m.ErrorPage500
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetErrorPage400() string {
	if m != nil {
		return m.ErrorPage400
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetSendFakeAuthorization() bool {
	if m != nil {
		return m.SendFakeAuthorization
	}
	return false
}

func (m *AddConfigHTTPRequest) GetForwardedHost() string {
	if m != nil {
		return m.ForwardedHost
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetConfigName() string {
	if m != nil {
		return m.ConfigName
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetProtocolRequired() string {
	if m != nil {
		return m.ProtocolRequired
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetAllowAuthorizationFromClient() bool {
	if m != nil {
		return m.AllowAuthorizationFromClient
	}
	return false
}

func (m *AddConfigHTTPRequest) GetForceBackendAuthorization() bool {
	if m != nil {
		return m.ForceBackendAuthorization
	}
	return false
}

func (m *AddConfigHTTPRequest) GetMaxInFlights() int32 {
	if m != nil {
		return m.MaxInFlights
	}
	return 0
}

func (m *AddConfigHTTPRequest) GetApi() uint32 {
	if m != nil {
		return m.Api
	}
	return 0
}

func (m *AddConfigHTTPRequest) GetRewriteRedirectHost() bool {
	if m != nil {
		return m.RewriteRedirectHost
	}
	return false
}

func (m *AddConfigHTTPRequest) GetUserNameForFakeAuth() string {
	if m != nil {
		return m.UserNameForFakeAuth
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetMaxPerSec() uint32 {
	if m != nil {
		return m.MaxPerSec
	}
	return 0
}

func (m *AddConfigHTTPRequest) GetRFC1918Only() bool {
	if m != nil {
		return m.RFC1918Only
	}
	return false
}

func (m *AddConfigHTTPRequest) GetAcceptHTTP() bool {
	if m != nil {
		return m.AcceptHTTP
	}
	return false
}

func (m *AddConfigHTTPRequest) GetProxyForHTTPS() bool {
	if m != nil {
		return m.ProxyForHTTPS
	}
	return false
}

func (m *AddConfigHTTPRequest) GetMaxDuration() uint32 {
	if m != nil {
		return m.MaxDuration
	}
	return 0
}

func (m *AddConfigHTTPRequest) GetDisableFormBasedAuth() bool {
	if m != nil {
		return m.DisableFormBasedAuth
	}
	return false
}

func (m *AddConfigHTTPRequest) GetLowLatency() bool {
	if m != nil {
		return m.LowLatency
	}
	return false
}

func (m *AddConfigHTTPRequest) GetWebBackendAuthenticatesOnly() bool {
	if m != nil {
		return m.WebBackendAuthenticatesOnly
	}
	return false
}

type HostListEntry struct {
	Hostname       string `protobuf:"bytes,1,opt,name=Hostname" json:"Hostname,omitempty"`
	GotCertificate bool   `protobuf:"varint,2,opt,name=GotCertificate" json:"GotCertificate,omitempty"`
	ServedHTTP     bool   `protobuf:"varint,3,opt,name=ServedHTTP" json:"ServedHTTP,omitempty"`
	ServedHTTPS    bool   `protobuf:"varint,4,opt,name=ServedHTTPS" json:"ServedHTTPS,omitempty"`
}

func (m *HostListEntry) Reset()                    { *m = HostListEntry{} }
func (m *HostListEntry) String() string            { return proto.CompactTextString(m) }
func (*HostListEntry) ProtoMessage()               {}
func (*HostListEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *HostListEntry) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *HostListEntry) GetGotCertificate() bool {
	if m != nil {
		return m.GotCertificate
	}
	return false
}

func (m *HostListEntry) GetServedHTTP() bool {
	if m != nil {
		return m.ServedHTTP
	}
	return false
}

func (m *HostListEntry) GetServedHTTPS() bool {
	if m != nil {
		return m.ServedHTTPS
	}
	return false
}

type HostList struct {
	Hosts []*HostListEntry `protobuf:"bytes,1,rep,name=Hosts" json:"Hosts,omitempty"`
}

func (m *HostList) Reset()                    { *m = HostList{} }
func (m *HostList) String() string            { return proto.CompactTextString(m) }
func (*HostList) ProtoMessage()               {}
func (*HostList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *HostList) GetHosts() []*HostListEntry {
	if m != nil {
		return m.Hosts
	}
	return nil
}

type BodyData struct {
	Response *StreamDataResponse `protobuf:"bytes,1,opt,name=Response" json:"Response,omitempty"`
}

func (m *BodyData) Reset()                    { *m = BodyData{} }
func (m *BodyData) String() string            { return proto.CompactTextString(m) }
func (*BodyData) ProtoMessage()               {}
func (*BodyData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *BodyData) GetResponse() *StreamDataResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type ConfigureProberRequest struct {
	ProberBackend bool `protobuf:"varint,1,opt,name=ProberBackend" json:"ProberBackend,omitempty"`
}

func (m *ConfigureProberRequest) Reset()                    { *m = ConfigureProberRequest{} }
func (m *ConfigureProberRequest) String() string            { return proto.CompactTextString(m) }
func (*ConfigureProberRequest) ProtoMessage()               {}
func (*ConfigureProberRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *ConfigureProberRequest) GetProberBackend() bool {
	if m != nil {
		return m.ProberBackend
	}
	return false
}

type TCPSession struct {
	// the port an external client connects to. This is what h2gproxy listens on
	InboundPort uint32 `protobuf:"varint,1,opt,name=InboundPort" json:"InboundPort,omitempty"`
	// the config attached to the inbound port
	Config *AddConfigHTTPRequest `protobuf:"bytes,2,opt,name=Config" json:"Config,omitempty"`
	// the ephemeral port assigned by the OS for the connection to the proxy target
	ProxyOutboundPort uint32 `protobuf:"varint,3,opt,name=ProxyOutboundPort" json:"ProxyOutboundPort,omitempty"`
	// the target we connected this session to
	ProxyTargetPort uint32 `protobuf:"varint,4,opt,name=ProxyTargetPort" json:"ProxyTargetPort,omitempty"`
	// the target we connected this session to
	ProxyTargetHost string `protobuf:"bytes,5,opt,name=ProxyTargetHost" json:"ProxyTargetHost,omitempty"`
	PeerHost        string `protobuf:"bytes,6,opt,name=PeerHost" json:"PeerHost,omitempty"`
	PeerPort        uint32 `protobuf:"varint,7,opt,name=PeerPort" json:"PeerPort,omitempty"`
}

func (m *TCPSession) Reset()                    { *m = TCPSession{} }
func (m *TCPSession) String() string            { return proto.CompactTextString(m) }
func (*TCPSession) ProtoMessage()               {}
func (*TCPSession) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *TCPSession) GetInboundPort() uint32 {
	if m != nil {
		return m.InboundPort
	}
	return 0
}

func (m *TCPSession) GetConfig() *AddConfigHTTPRequest {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *TCPSession) GetProxyOutboundPort() uint32 {
	if m != nil {
		return m.ProxyOutboundPort
	}
	return 0
}

func (m *TCPSession) GetProxyTargetPort() uint32 {
	if m != nil {
		return m.ProxyTargetPort
	}
	return 0
}

func (m *TCPSession) GetProxyTargetHost() string {
	if m != nil {
		return m.ProxyTargetHost
	}
	return ""
}

func (m *TCPSession) GetPeerHost() string {
	if m != nil {
		return m.PeerHost
	}
	return ""
}

func (m *TCPSession) GetPeerPort() uint32 {
	if m != nil {
		return m.PeerPort
	}
	return 0
}

type TCPSessionList struct {
	Sessions []*TCPSession `protobuf:"bytes,1,rep,name=Sessions" json:"Sessions,omitempty"`
}

func (m *TCPSessionList) Reset()                    { *m = TCPSessionList{} }
func (m *TCPSessionList) String() string            { return proto.CompactTextString(m) }
func (*TCPSessionList) ProtoMessage()               {}
func (*TCPSessionList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *TCPSessionList) GetSessions() []*TCPSession {
	if m != nil {
		return m.Sessions
	}
	return nil
}

//
// TCP defines a connection by {IP1, Port1, IP2, Port2 }. This means, it is possible (albeit in practice not
// wide spread) that a ProxyOutboundPort is reused if connecting to different instances.
// this is the connection in the datacenter
type TCPMetaRequest struct {
	ProxyOutboundPort uint32 `protobuf:"varint,1,opt,name=ProxyOutboundPort" json:"ProxyOutboundPort,omitempty"`
	ProxyOutboundHost string `protobuf:"bytes,2,opt,name=ProxyOutboundHost" json:"ProxyOutboundHost,omitempty"`
	ProxyTargetPort   uint32 `protobuf:"varint,3,opt,name=ProxyTargetPort" json:"ProxyTargetPort,omitempty"`
	ProxyTargetHost   string `protobuf:"bytes,4,opt,name=ProxyTargetHost" json:"ProxyTargetHost,omitempty"`
}

func (m *TCPMetaRequest) Reset()                    { *m = TCPMetaRequest{} }
func (m *TCPMetaRequest) String() string            { return proto.CompactTextString(m) }
func (*TCPMetaRequest) ProtoMessage()               {}
func (*TCPMetaRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *TCPMetaRequest) GetProxyOutboundPort() uint32 {
	if m != nil {
		return m.ProxyOutboundPort
	}
	return 0
}

func (m *TCPMetaRequest) GetProxyOutboundHost() string {
	if m != nil {
		return m.ProxyOutboundHost
	}
	return ""
}

func (m *TCPMetaRequest) GetProxyTargetPort() uint32 {
	if m != nil {
		return m.ProxyTargetPort
	}
	return 0
}

func (m *TCPMetaRequest) GetProxyTargetHost() string {
	if m != nil {
		return m.ProxyTargetHost
	}
	return ""
}

func init() {
	proto.RegisterType((*CreateConfigRequest)(nil), "h2gproxy.CreateConfigRequest")
	proto.RegisterType((*CreateConfigResponse)(nil), "h2gproxy.CreateConfigResponse")
	proto.RegisterType((*ApplyConfigRequest)(nil), "h2gproxy.ApplyConfigRequest")
	proto.RegisterType((*ApplyConfigResponse)(nil), "h2gproxy.ApplyConfigResponse")
	proto.RegisterType((*AddConfigResponse)(nil), "h2gproxy.AddConfigResponse")
	proto.RegisterType((*AddConfigTCPRequest)(nil), "h2gproxy.AddConfigTCPRequest")
	proto.RegisterType((*Header)(nil), "h2gproxy.Header")
	proto.RegisterType((*Parameter)(nil), "h2gproxy.Parameter")
	proto.RegisterType((*StreamDataResponse)(nil), "h2gproxy.StreamDataResponse")
	proto.RegisterType((*StreamRequest)(nil), "h2gproxy.StreamRequest")
	proto.RegisterType((*StreamResponse)(nil), "h2gproxy.StreamResponse")
	proto.RegisterType((*StreamDataRequest)(nil), "h2gproxy.StreamDataRequest")
	proto.RegisterType((*ServeRequest)(nil), "h2gproxy.ServeRequest")
	proto.RegisterType((*Cookie)(nil), "h2gproxy.Cookie")
	proto.RegisterType((*ServeResponse)(nil), "h2gproxy.ServeResponse")
	proto.RegisterType((*Config)(nil), "h2gproxy.Config")
	proto.RegisterType((*AddConfigHTTPRequest)(nil), "h2gproxy.AddConfigHTTPRequest")
	proto.RegisterType((*HostListEntry)(nil), "h2gproxy.HostListEntry")
	proto.RegisterType((*HostList)(nil), "h2gproxy.HostList")
	proto.RegisterType((*BodyData)(nil), "h2gproxy.BodyData")
	proto.RegisterType((*ConfigureProberRequest)(nil), "h2gproxy.ConfigureProberRequest")
	proto.RegisterType((*TCPSession)(nil), "h2gproxy.TCPSession")
	proto.RegisterType((*TCPSessionList)(nil), "h2gproxy.TCPSessionList")
	proto.RegisterType((*TCPMetaRequest)(nil), "h2gproxy.TCPMetaRequest")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DownloadStreamer service

type DownloadStreamerClient interface {
	//
	// Implementors Note: There are two types of errors, that somewhat overlap:
	// 1. The backend service encounters an unhandled error
	// 2. The backend service is unable to locate a resource (e.g. URL returns 404)
	// The streaming proxy distinguishes between errors returned from the backend vs http codes indicated through stream response. Generally, if the backend suceeds, that is, the codepath goes through anticipated states, it should not throw an error, but indicate the status through its response instead. errors should be reserved for errors encountered by the backend itself. That is, don't just blindly wrap errors ;)
	StreamHTTP(ctx context.Context, in *StreamRequest, opts ...grpc.CallOption) (DownloadStreamer_StreamHTTPClient, error)
}

type downloadStreamerClient struct {
	cc *grpc.ClientConn
}

func NewDownloadStreamerClient(cc *grpc.ClientConn) DownloadStreamerClient {
	return &downloadStreamerClient{cc}
}

func (c *downloadStreamerClient) StreamHTTP(ctx context.Context, in *StreamRequest, opts ...grpc.CallOption) (DownloadStreamer_StreamHTTPClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DownloadStreamer_serviceDesc.Streams[0], c.cc, "/h2gproxy.DownloadStreamer/StreamHTTP", opts...)
	if err != nil {
		return nil, err
	}
	x := &downloadStreamerStreamHTTPClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DownloadStreamer_StreamHTTPClient interface {
	Recv() (*StreamDataResponse, error)
	grpc.ClientStream
}

type downloadStreamerStreamHTTPClient struct {
	grpc.ClientStream
}

func (x *downloadStreamerStreamHTTPClient) Recv() (*StreamDataResponse, error) {
	m := new(StreamDataResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for DownloadStreamer service

type DownloadStreamerServer interface {
	//
	// Implementors Note: There are two types of errors, that somewhat overlap:
	// 1. The backend service encounters an unhandled error
	// 2. The backend service is unable to locate a resource (e.g. URL returns 404)
	// The streaming proxy distinguishes between errors returned from the backend vs http codes indicated through stream response. Generally, if the backend suceeds, that is, the codepath goes through anticipated states, it should not throw an error, but indicate the status through its response instead. errors should be reserved for errors encountered by the backend itself. That is, don't just blindly wrap errors ;)
	StreamHTTP(*StreamRequest, DownloadStreamer_StreamHTTPServer) error
}

func RegisterDownloadStreamerServer(s *grpc.Server, srv DownloadStreamerServer) {
	s.RegisterService(&_DownloadStreamer_serviceDesc, srv)
}

func _DownloadStreamer_StreamHTTP_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DownloadStreamerServer).StreamHTTP(m, &downloadStreamerStreamHTTPServer{stream})
}

type DownloadStreamer_StreamHTTPServer interface {
	Send(*StreamDataResponse) error
	grpc.ServerStream
}

type downloadStreamerStreamHTTPServer struct {
	grpc.ServerStream
}

func (x *downloadStreamerStreamHTTPServer) Send(m *StreamDataResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _DownloadStreamer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "h2gproxy.DownloadStreamer",
	HandlerType: (*DownloadStreamerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamHTTP",
			Handler:       _DownloadStreamer_StreamHTTP_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protos/golang.conradwood.net/apis/h2gproxy/h2gproxy.proto",
}

// Client API for H2GProxyService service

type H2GProxyServiceClient interface {
	// create a new config. This doesn't affect current operation until apply is
	// called
	CreateConfig(ctx context.Context, in *CreateConfigRequest, opts ...grpc.CallOption) (*CreateConfigResponse, error)
	// this applies a new config
	ApplyConfig(ctx context.Context, in *ApplyConfigRequest, opts ...grpc.CallOption) (*ApplyConfigResponse, error)
	AddConfigTCP(ctx context.Context, in *AddConfigTCPRequest, opts ...grpc.CallOption) (*AddConfigResponse, error)
	AddConfigHTTP(ctx context.Context, in *AddConfigHTTPRequest, opts ...grpc.CallOption) (*AddConfigResponse, error)
	// get current config
	GetConfig(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*Config, error)
	// get all hosts for which we at least once successfully served something and/or for which we have a valid certificate
	GetKnownHosts(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*HostList, error)
	// implemented for probers
	BiStreamHTTP(ctx context.Context, opts ...grpc.CallOption) (H2GProxyService_BiStreamHTTPClient, error)
	// implemented for probers
	StreamHTTP(ctx context.Context, in *StreamRequest, opts ...grpc.CallOption) (H2GProxyService_StreamHTTPClient, error)
	// implemented for probers
	ServeHTML(ctx context.Context, in *ServeRequest, opts ...grpc.CallOption) (*ServeResponse, error)
	// implemented for probers
	Serve(ctx context.Context, in *ServeRequest, opts ...grpc.CallOption) (*ServeResponse, error)
	// switch prober backend on or off (useful if a running h2gproxy needs to be probed)
	// this rpc is limited to root users
	ConfigureProber(ctx context.Context, in *ConfigureProberRequest, opts ...grpc.CallOption) (*common.Void, error)
	// we can get some meta information about proxied tcp connections here
	GetTCPMeta(ctx context.Context, in *TCPMetaRequest, opts ...grpc.CallOption) (*TCPSession, error)
	// list of currently proxied tcp requests
	GetTCPSessions(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*TCPSessionList, error)
}

type h2GProxyServiceClient struct {
	cc *grpc.ClientConn
}

func NewH2GProxyServiceClient(cc *grpc.ClientConn) H2GProxyServiceClient {
	return &h2GProxyServiceClient{cc}
}

func (c *h2GProxyServiceClient) CreateConfig(ctx context.Context, in *CreateConfigRequest, opts ...grpc.CallOption) (*CreateConfigResponse, error) {
	out := new(CreateConfigResponse)
	err := grpc.Invoke(ctx, "/h2gproxy.H2GProxyService/CreateConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *h2GProxyServiceClient) ApplyConfig(ctx context.Context, in *ApplyConfigRequest, opts ...grpc.CallOption) (*ApplyConfigResponse, error) {
	out := new(ApplyConfigResponse)
	err := grpc.Invoke(ctx, "/h2gproxy.H2GProxyService/ApplyConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *h2GProxyServiceClient) AddConfigTCP(ctx context.Context, in *AddConfigTCPRequest, opts ...grpc.CallOption) (*AddConfigResponse, error) {
	out := new(AddConfigResponse)
	err := grpc.Invoke(ctx, "/h2gproxy.H2GProxyService/AddConfigTCP", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *h2GProxyServiceClient) AddConfigHTTP(ctx context.Context, in *AddConfigHTTPRequest, opts ...grpc.CallOption) (*AddConfigResponse, error) {
	out := new(AddConfigResponse)
	err := grpc.Invoke(ctx, "/h2gproxy.H2GProxyService/AddConfigHTTP", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *h2GProxyServiceClient) GetConfig(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*Config, error) {
	out := new(Config)
	err := grpc.Invoke(ctx, "/h2gproxy.H2GProxyService/GetConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *h2GProxyServiceClient) GetKnownHosts(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*HostList, error) {
	out := new(HostList)
	err := grpc.Invoke(ctx, "/h2gproxy.H2GProxyService/GetKnownHosts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *h2GProxyServiceClient) BiStreamHTTP(ctx context.Context, opts ...grpc.CallOption) (H2GProxyService_BiStreamHTTPClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_H2GProxyService_serviceDesc.Streams[0], c.cc, "/h2gproxy.H2GProxyService/BiStreamHTTP", opts...)
	if err != nil {
		return nil, err
	}
	x := &h2GProxyServiceBiStreamHTTPClient{stream}
	return x, nil
}

type H2GProxyService_BiStreamHTTPClient interface {
	Send(*StreamDataRequest) error
	Recv() (*StreamDataResponse, error)
	grpc.ClientStream
}

type h2GProxyServiceBiStreamHTTPClient struct {
	grpc.ClientStream
}

func (x *h2GProxyServiceBiStreamHTTPClient) Send(m *StreamDataRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *h2GProxyServiceBiStreamHTTPClient) Recv() (*StreamDataResponse, error) {
	m := new(StreamDataResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *h2GProxyServiceClient) StreamHTTP(ctx context.Context, in *StreamRequest, opts ...grpc.CallOption) (H2GProxyService_StreamHTTPClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_H2GProxyService_serviceDesc.Streams[1], c.cc, "/h2gproxy.H2GProxyService/StreamHTTP", opts...)
	if err != nil {
		return nil, err
	}
	x := &h2GProxyServiceStreamHTTPClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type H2GProxyService_StreamHTTPClient interface {
	Recv() (*StreamDataResponse, error)
	grpc.ClientStream
}

type h2GProxyServiceStreamHTTPClient struct {
	grpc.ClientStream
}

func (x *h2GProxyServiceStreamHTTPClient) Recv() (*StreamDataResponse, error) {
	m := new(StreamDataResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *h2GProxyServiceClient) ServeHTML(ctx context.Context, in *ServeRequest, opts ...grpc.CallOption) (*ServeResponse, error) {
	out := new(ServeResponse)
	err := grpc.Invoke(ctx, "/h2gproxy.H2GProxyService/ServeHTML", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *h2GProxyServiceClient) Serve(ctx context.Context, in *ServeRequest, opts ...grpc.CallOption) (*ServeResponse, error) {
	out := new(ServeResponse)
	err := grpc.Invoke(ctx, "/h2gproxy.H2GProxyService/Serve", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *h2GProxyServiceClient) ConfigureProber(ctx context.Context, in *ConfigureProberRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/h2gproxy.H2GProxyService/ConfigureProber", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *h2GProxyServiceClient) GetTCPMeta(ctx context.Context, in *TCPMetaRequest, opts ...grpc.CallOption) (*TCPSession, error) {
	out := new(TCPSession)
	err := grpc.Invoke(ctx, "/h2gproxy.H2GProxyService/GetTCPMeta", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *h2GProxyServiceClient) GetTCPSessions(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*TCPSessionList, error) {
	out := new(TCPSessionList)
	err := grpc.Invoke(ctx, "/h2gproxy.H2GProxyService/GetTCPSessions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for H2GProxyService service

type H2GProxyServiceServer interface {
	// create a new config. This doesn't affect current operation until apply is
	// called
	CreateConfig(context.Context, *CreateConfigRequest) (*CreateConfigResponse, error)
	// this applies a new config
	ApplyConfig(context.Context, *ApplyConfigRequest) (*ApplyConfigResponse, error)
	AddConfigTCP(context.Context, *AddConfigTCPRequest) (*AddConfigResponse, error)
	AddConfigHTTP(context.Context, *AddConfigHTTPRequest) (*AddConfigResponse, error)
	// get current config
	GetConfig(context.Context, *common.Void) (*Config, error)
	// get all hosts for which we at least once successfully served something and/or for which we have a valid certificate
	GetKnownHosts(context.Context, *common.Void) (*HostList, error)
	// implemented for probers
	BiStreamHTTP(H2GProxyService_BiStreamHTTPServer) error
	// implemented for probers
	StreamHTTP(*StreamRequest, H2GProxyService_StreamHTTPServer) error
	// implemented for probers
	ServeHTML(context.Context, *ServeRequest) (*ServeResponse, error)
	// implemented for probers
	Serve(context.Context, *ServeRequest) (*ServeResponse, error)
	// switch prober backend on or off (useful if a running h2gproxy needs to be probed)
	// this rpc is limited to root users
	ConfigureProber(context.Context, *ConfigureProberRequest) (*common.Void, error)
	// we can get some meta information about proxied tcp connections here
	GetTCPMeta(context.Context, *TCPMetaRequest) (*TCPSession, error)
	// list of currently proxied tcp requests
	GetTCPSessions(context.Context, *common.Void) (*TCPSessionList, error)
}

func RegisterH2GProxyServiceServer(s *grpc.Server, srv H2GProxyServiceServer) {
	s.RegisterService(&_H2GProxyService_serviceDesc, srv)
}

func _H2GProxyService_CreateConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(H2GProxyServiceServer).CreateConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/h2gproxy.H2GProxyService/CreateConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(H2GProxyServiceServer).CreateConfig(ctx, req.(*CreateConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _H2GProxyService_ApplyConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(H2GProxyServiceServer).ApplyConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/h2gproxy.H2GProxyService/ApplyConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(H2GProxyServiceServer).ApplyConfig(ctx, req.(*ApplyConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _H2GProxyService_AddConfigTCP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddConfigTCPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(H2GProxyServiceServer).AddConfigTCP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/h2gproxy.H2GProxyService/AddConfigTCP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(H2GProxyServiceServer).AddConfigTCP(ctx, req.(*AddConfigTCPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _H2GProxyService_AddConfigHTTP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddConfigHTTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(H2GProxyServiceServer).AddConfigHTTP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/h2gproxy.H2GProxyService/AddConfigHTTP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(H2GProxyServiceServer).AddConfigHTTP(ctx, req.(*AddConfigHTTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _H2GProxyService_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(H2GProxyServiceServer).GetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/h2gproxy.H2GProxyService/GetConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(H2GProxyServiceServer).GetConfig(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _H2GProxyService_GetKnownHosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(H2GProxyServiceServer).GetKnownHosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/h2gproxy.H2GProxyService/GetKnownHosts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(H2GProxyServiceServer).GetKnownHosts(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _H2GProxyService_BiStreamHTTP_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(H2GProxyServiceServer).BiStreamHTTP(&h2GProxyServiceBiStreamHTTPServer{stream})
}

type H2GProxyService_BiStreamHTTPServer interface {
	Send(*StreamDataResponse) error
	Recv() (*StreamDataRequest, error)
	grpc.ServerStream
}

type h2GProxyServiceBiStreamHTTPServer struct {
	grpc.ServerStream
}

func (x *h2GProxyServiceBiStreamHTTPServer) Send(m *StreamDataResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *h2GProxyServiceBiStreamHTTPServer) Recv() (*StreamDataRequest, error) {
	m := new(StreamDataRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _H2GProxyService_StreamHTTP_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(H2GProxyServiceServer).StreamHTTP(m, &h2GProxyServiceStreamHTTPServer{stream})
}

type H2GProxyService_StreamHTTPServer interface {
	Send(*StreamDataResponse) error
	grpc.ServerStream
}

type h2GProxyServiceStreamHTTPServer struct {
	grpc.ServerStream
}

func (x *h2GProxyServiceStreamHTTPServer) Send(m *StreamDataResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _H2GProxyService_ServeHTML_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(H2GProxyServiceServer).ServeHTML(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/h2gproxy.H2GProxyService/ServeHTML",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(H2GProxyServiceServer).ServeHTML(ctx, req.(*ServeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _H2GProxyService_Serve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(H2GProxyServiceServer).Serve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/h2gproxy.H2GProxyService/Serve",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(H2GProxyServiceServer).Serve(ctx, req.(*ServeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _H2GProxyService_ConfigureProber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureProberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(H2GProxyServiceServer).ConfigureProber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/h2gproxy.H2GProxyService/ConfigureProber",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(H2GProxyServiceServer).ConfigureProber(ctx, req.(*ConfigureProberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _H2GProxyService_GetTCPMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TCPMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(H2GProxyServiceServer).GetTCPMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/h2gproxy.H2GProxyService/GetTCPMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(H2GProxyServiceServer).GetTCPMeta(ctx, req.(*TCPMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _H2GProxyService_GetTCPSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(H2GProxyServiceServer).GetTCPSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/h2gproxy.H2GProxyService/GetTCPSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(H2GProxyServiceServer).GetTCPSessions(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

var _H2GProxyService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "h2gproxy.H2GProxyService",
	HandlerType: (*H2GProxyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateConfig",
			Handler:    _H2GProxyService_CreateConfig_Handler,
		},
		{
			MethodName: "ApplyConfig",
			Handler:    _H2GProxyService_ApplyConfig_Handler,
		},
		{
			MethodName: "AddConfigTCP",
			Handler:    _H2GProxyService_AddConfigTCP_Handler,
		},
		{
			MethodName: "AddConfigHTTP",
			Handler:    _H2GProxyService_AddConfigHTTP_Handler,
		},
		{
			MethodName: "GetConfig",
			Handler:    _H2GProxyService_GetConfig_Handler,
		},
		{
			MethodName: "GetKnownHosts",
			Handler:    _H2GProxyService_GetKnownHosts_Handler,
		},
		{
			MethodName: "ServeHTML",
			Handler:    _H2GProxyService_ServeHTML_Handler,
		},
		{
			MethodName: "Serve",
			Handler:    _H2GProxyService_Serve_Handler,
		},
		{
			MethodName: "ConfigureProber",
			Handler:    _H2GProxyService_ConfigureProber_Handler,
		},
		{
			MethodName: "GetTCPMeta",
			Handler:    _H2GProxyService_GetTCPMeta_Handler,
		},
		{
			MethodName: "GetTCPSessions",
			Handler:    _H2GProxyService_GetTCPSessions_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "BiStreamHTTP",
			Handler:       _H2GProxyService_BiStreamHTTP_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamHTTP",
			Handler:       _H2GProxyService_StreamHTTP_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protos/golang.conradwood.net/apis/h2gproxy/h2gproxy.proto",
}

func init() {
	proto.RegisterFile("protos/golang.conradwood.net/apis/h2gproxy/h2gproxy.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1807 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xd4, 0x58, 0xdd, 0x52, 0x1b, 0xc9,
	0x15, 0x2e, 0x89, 0x3f, 0xe9, 0x80, 0x30, 0x34, 0xd8, 0xee, 0x95, 0x7f, 0x42, 0x66, 0x53, 0x5b,
	0x14, 0x49, 0xb0, 0xcc, 0xb2, 0x29, 0x9c, 0x72, 0x25, 0x2b, 0x04, 0x02, 0x7b, 0xc1, 0xab, 0x8c,
	0xe4, 0x4d, 0x65, 0x2f, 0x52, 0x35, 0x68, 0xda, 0x30, 0x85, 0x98, 0x56, 0x7a, 0x5a, 0x06, 0xf9,
	0x11, 0x52, 0x95, 0xbb, 0xe4, 0x3e, 0xb9, 0xce, 0x4b, 0xe4, 0x45, 0xf2, 0x0c, 0x79, 0x85, 0xd4,
	0x39, 0x3d, 0x3f, 0x3d, 0x23, 0x41, 0x48, 0x2a, 0x37, 0x7b, 0xa5, 0x3e, 0x5f, 0x9f, 0xfe, 0xfb,
	0xce, 0xd7, 0xe7, 0xb4, 0x06, 0x5e, 0x0d, 0x95, 0xd4, 0x32, 0x7a, 0x71, 0x2e, 0x07, 0x5e, 0x78,
	0xbe, 0xdd, 0x97, 0xa1, 0xf2, 0xfc, 0x6b, 0x29, 0xfd, 0xed, 0x50, 0xe8, 0x17, 0xde, 0x30, 0x88,
	0x5e, 0x5c, 0xec, 0x9c, 0x0f, 0x95, 0xbc, 0x19, 0xa7, 0x8d, 0x6d, 0x1a, 0xc3, 0x2a, 0x89, 0x5d,
	0xdf, 0xbe, 0x63, 0x74, 0x5f, 0x5e, 0x5d, 0xc9, 0x30, 0xfe, 0x31, 0x23, 0x9d, 0x87, 0xb0, 0xd6,
	0x52, 0xc2, 0xd3, 0xa2, 0x25, 0xc3, 0x0f, 0xc1, 0xb9, 0x2b, 0xfe, 0x30, 0x12, 0x91, 0x76, 0x76,
	0x60, 0x3d, 0x0f, 0x47, 0x43, 0x19, 0x46, 0x82, 0xd5, 0xa1, 0x62, 0x90, 0x37, 0x07, 0xbc, 0xb4,
	0x51, 0xda, 0xac, 0xba, 0xa9, 0xed, 0x34, 0x80, 0x35, 0x87, 0xc3, 0xc1, 0x38, 0x37, 0xd3, 0x9d,
	0x23, 0x5e, 0xc0, 0x5a, 0x6e, 0x44, 0xbc, 0x08, 0x87, 0x05, 0x84, 0x03, 0xe1, 0xd3, 0x88, 0x8a,
	0x9b, 0x98, 0xce, 0x1a, 0xac, 0x36, 0x7d, 0x3f, 0xef, 0xee, 0xfc, 0xbd, 0x04, 0x6b, 0x29, 0xda,
	0x6b, 0x75, 0xee, 0xb1, 0x32, 0x7b, 0x0e, 0xd0, 0x95, 0x23, 0xd5, 0x17, 0x1d, 0xa9, 0x34, 0x2f,
	0x6f, 0x94, 0x36, 0xe7, 0x5c, 0x0b, 0x61, 0x3f, 0x83, 0xd5, 0x9e, 0xa7, 0xce, 0x85, 0xee, 0x0a,
	0xf5, 0x31, 0xe8, 0x8b, 0x8e, 0xa7, 0x2f, 0xf8, 0x0c, 0x4d, 0x32, 0xd9, 0xc1, 0xb6, 0x60, 0xe5,
	0x1b, 0x21, 0x86, 0xcd, 0x41, 0xf0, 0x51, 0x74, 0x45, 0x5f, 0x86, 0x7e, 0xc4, 0x67, 0x37, 0x4a,
	0x9b, 0x35, 0x77, 0x02, 0x77, 0x76, 0x61, 0xfe, 0x58, 0x78, 0xbe, 0x50, 0x8c, 0xc1, 0xec, 0x3b,
	0xef, 0x4a, 0xc4, 0x7b, 0xa3, 0x36, 0x7b, 0x04, 0xf3, 0xdf, 0x79, 0x83, 0x91, 0x88, 0x78, 0x79,
	0x63, 0x66, 0xb3, 0xea, 0xc6, 0x96, 0xf3, 0x15, 0x54, 0x3b, 0x9e, 0xf2, 0xae, 0x84, 0xbe, 0x65,
	0xe0, 0x3a, 0xcc, 0x91, 0x2b, 0x9d, 0xa5, 0xea, 0x1a, 0xc3, 0xf9, 0x3d, 0xb0, 0xae, 0x56, 0xc2,
	0xbb, 0x3a, 0xf0, 0xb4, 0x97, 0xf2, 0xbb, 0x0b, 0x95, 0xa4, 0x4d, 0x73, 0x2c, 0xee, 0xf0, 0xed,
	0x54, 0x50, 0xc6, 0x3f, 0xe9, 0x77, 0x53, 0x4f, 0x5c, 0x15, 0x67, 0xa1, 0x05, 0x96, 0x5c, 0x6a,
	0x3b, 0x7f, 0x2e, 0x43, 0x2d, 0x19, 0x60, 0x48, 0xdf, 0x82, 0x05, 0x73, 0xbc, 0x88, 0x97, 0x36,
	0x66, 0x36, 0x17, 0x77, 0x56, 0xb2, 0xa9, 0x4d, 0x87, 0x9b, 0x38, 0xe0, 0x8c, 0x16, 0xaf, 0xd4,
	0x46, 0x02, 0x4e, 0x85, 0xbe, 0x90, 0x3e, 0x11, 0x58, 0x75, 0x63, 0x8b, 0x7d, 0x09, 0x90, 0x12,
	0x10, 0xf1, 0x39, 0x9a, 0x7a, 0x2d, 0x9b, 0x3a, 0xed, 0x73, 0x2d, 0x37, 0x5c, 0xe0, 0x58, 0x46,
	0x9a, 0xcf, 0x9b, 0x05, 0xb0, 0xcd, 0x9e, 0x42, 0xf5, 0x7d, 0x24, 0x54, 0xf3, 0x5c, 0x84, 0x9a,
	0x2f, 0x50, 0x47, 0x06, 0xa0, 0x66, 0x8c, 0x0a, 0xde, 0x74, 0x78, 0xc5, 0x68, 0x26, 0xb1, 0x91,
	0xe2, 0xdf, 0x8c, 0x84, 0x1a, 0xf3, 0xaa, 0xa1, 0x98, 0x0c, 0x3a, 0x04, 0x6a, 0x08, 0x28, 0xde,
	0xd4, 0x76, 0xfe, 0x54, 0x86, 0xe5, 0x3c, 0x8f, 0x38, 0x71, 0x3b, 0x18, 0x88, 0x30, 0x8b, 0x5b,
	0x6a, 0xe3, 0x14, 0xdd, 0xe0, 0x93, 0x09, 0xdd, 0xac, 0x4b, 0x6d, 0xf4, 0x3f, 0x0d, 0xae, 0x44,
	0x6f, 0x3c, 0x14, 0x31, 0x3f, 0xa9, 0xcd, 0xde, 0xc1, 0xd2, 0xe1, 0x8d, 0x56, 0x5e, 0x42, 0xf4,
	0x2c, 0xb1, 0xb1, 0x75, 0x5b, 0x0c, 0xb7, 0x6d, 0xe7, 0xc3, 0x50, 0xab, 0xb1, 0x9b, 0x1b, 0x4f,
	0x97, 0x41, 0x7b, 0x7a, 0x14, 0xb5, 0xa4, 0x2f, 0xf8, 0x1c, 0x1d, 0xc4, 0x42, 0xea, 0xbf, 0x86,
	0xd5, 0x89, 0x29, 0xd8, 0x0a, 0xcc, 0x5c, 0x8a, 0x71, 0x7c, 0x16, 0x6c, 0x22, 0x3f, 0x1f, 0x6d,
	0x09, 0x92, 0xf1, 0xcb, 0xf2, 0x5e, 0xc9, 0xf9, 0x1e, 0x56, 0x6d, 0x19, 0x1a, 0xa5, 0xbc, 0x84,
	0x85, 0xb8, 0x19, 0x8b, 0xf0, 0xf1, 0xe4, 0x01, 0xa8, 0xdb, 0x4d, 0xfc, 0xa6, 0x4a, 0xf0, 0x6f,
	0x65, 0x58, 0xc2, 0xbb, 0x28, 0xfe, 0x47, 0x05, 0xee, 0x4b, 0x7f, 0x1c, 0xef, 0x98, 0xda, 0x3f,
	0x34, 0x55, 0x3a, 0x78, 0xfc, 0x28, 0x0a, 0x64, 0xd8, 0x93, 0x97, 0x22, 0x8c, 0xc5, 0x99, 0xc3,
	0x9c, 0xb7, 0x30, 0xdf, 0x92, 0xf2, 0x32, 0x10, 0xf7, 0x4f, 0x1d, 0x78, 0xe4, 0xc3, 0x9b, 0x61,
	0xa0, 0xc6, 0x44, 0x44, 0xcd, 0x8d, 0x2d, 0xe7, 0x9f, 0x25, 0xa8, 0xc5, 0x7c, 0xc7, 0xd2, 0xde,
	0x82, 0x95, 0xe3, 0x5e, 0xaf, 0x93, 0xd8, 0x24, 0xa2, 0x92, 0xc9, 0x7e, 0x45, 0x1c, 0x4f, 0x72,
	0xe4, 0x76, 0x5a, 0xe4, 0x53, 0x26, 0x9f, 0xd4, 0xce, 0x49, 0x7e, 0xb6, 0x20, 0xf9, 0x2d, 0x58,
	0x30, 0x27, 0x48, 0x58, 0xb6, 0x82, 0x6a, 0x3a, 0xdc, 0xc4, 0x21, 0x0d, 0xea, 0xbc, 0x51, 0x09,
	0x05, 0x75, 0x13, 0x1e, 0xb8, 0xc2, 0x0f, 0x94, 0xe8, 0xeb, 0x9e, 0xec, 0x0e, 0xbc, 0xe8, 0x82,
	0x58, 0xae, 0xb8, 0x45, 0xd8, 0xf9, 0x1a, 0xb9, 0xc2, 0x2a, 0xc1, 0x7e, 0x91, 0xb4, 0x62, 0x1d,
	0x3d, 0xcf, 0x96, 0x4c, 0xcb, 0x8d, 0x39, 0xa0, 0x91, 0x69, 0xec, 0xed, 0xfc, 0x11, 0x60, 0x7d,
	0x9a, 0xc3, 0x9d, 0x05, 0x89, 0xc3, 0xc2, 0x7b, 0xf7, 0x84, 0x84, 0x67, 0xc2, 0x90, 0x98, 0x78,
	0x3b, 0x4d, 0xc5, 0x21, 0xd1, 0x18, 0x55, 0x5a, 0x48, 0xd6, 0x4f, 0x69, 0x68, 0xd6, 0x94, 0xb2,
	0x0c, 0x61, 0x3f, 0x81, 0x5a, 0xae, 0x62, 0xd1, 0x05, 0xaf, 0xba, 0x79, 0x10, 0x05, 0x68, 0x80,
	0xf7, 0xee, 0x49, 0xac, 0xcc, 0x0c, 0x60, 0x5f, 0xc0, 0x72, 0xb6, 0x22, 0xe5, 0x30, 0xa3, 0xd1,
	0x02, 0x8a, 0x7b, 0xc1, 0x3d, 0x77, 0x94, 0xf8, 0x10, 0xdc, 0xc4, 0x52, 0xb5, 0x10, 0x14, 0x95,
	0xb9, 0x7a, 0xbc, 0x6a, 0xca, 0x5b, 0x5c, 0x0a, 0xeb, 0x50, 0x79, 0x27, 0x84, 0xdf, 0x1c, 0xe9,
	0x0b, 0x4a, 0xa4, 0x15, 0x37, 0xb5, 0x71, 0xcc, 0x91, 0x92, 0xa3, 0x61, 0xc4, 0x17, 0xcd, 0x18,
	0x63, 0xa1, 0x6c, 0xf1, 0x86, 0x44, 0x7c, 0x89, 0x60, 0x63, 0xb0, 0x0d, 0x58, 0x7c, 0xef, 0x9e,
	0xa4, 0xdb, 0xac, 0xd1, 0x16, 0x6c, 0x08, 0x2f, 0x4c, 0x5b, 0xaa, 0x6b, 0x4f, 0xf9, 0xc2, 0x6f,
	0x4b, 0xc5, 0x97, 0xcd, 0x85, 0xb1, 0x31, 0xf4, 0x39, 0x54, 0x4a, 0xaa, 0x8e, 0x77, 0x2e, 0xbe,
	0x6a, 0x34, 0xf8, 0x03, 0xe3, 0x63, 0x63, 0x39, 0x9f, 0xdd, 0x46, 0x83, 0xaf, 0x14, 0x7c, 0x76,
	0x1b, 0x0d, 0xb6, 0x0b, 0x0f, 0xbb, 0x22, 0xf4, 0xdb, 0xde, 0xa5, 0xc0, 0xb3, 0x48, 0x15, 0x7c,
	0xf2, 0x74, 0x20, 0x43, 0xbe, 0x4a, 0x87, 0x9c, 0xde, 0x89, 0x11, 0x4b, 0x77, 0x43, 0x41, 0x67,
	0x26, 0x62, 0x39, 0x10, 0xb9, 0x36, 0xea, 0xa1, 0x0b, 0xbd, 0x66, 0xb8, 0xce, 0x10, 0xbc, 0x96,
	0x1d, 0x7c, 0xe2, 0xf5, 0xe5, 0x00, 0x05, 0x18, 0x28, 0xe1, 0xf3, 0x75, 0xf2, 0x9a, 0xc0, 0xd9,
	0x3e, 0x3c, 0x6d, 0x0e, 0x06, 0xf2, 0x3a, 0xb7, 0x8f, 0xb6, 0x92, 0x57, 0xad, 0x41, 0x80, 0x19,
	0xe9, 0x21, 0x6d, 0xf7, 0x4e, 0x1f, 0xf6, 0x1a, 0x3e, 0x6b, 0x4b, 0xd5, 0x17, 0xfb, 0x5e, 0xff,
	0x52, 0x84, 0x7e, 0xfe, 0xbc, 0x8f, 0x68, 0x82, 0xdb, 0x1d, 0x90, 0xcd, 0x53, 0xef, 0xe6, 0x4d,
	0xd8, 0x1e, 0x04, 0xe7, 0x17, 0x3a, 0xe2, 0x8f, 0x49, 0xc7, 0x39, 0x0c, 0x4b, 0x4e, 0x73, 0x18,
	0x70, 0x4e, 0x79, 0x03, 0x9b, 0xac, 0x01, 0x6b, 0xae, 0xb8, 0x56, 0x81, 0x16, 0xc9, 0x35, 0x26,
	0xbe, 0x3e, 0xa3, 0xd5, 0xa6, 0x75, 0xe1, 0x08, 0x14, 0x0a, 0x32, 0xd4, 0x96, 0x2a, 0xe1, 0x9e,
	0xd7, 0x89, 0x98, 0x69, 0x5d, 0x78, 0x33, 0x4e, 0xbd, 0x9b, 0x8e, 0x50, 0x5d, 0xd1, 0xe7, 0x4f,
	0x68, 0xed, 0x0c, 0x40, 0xbd, 0xb9, 0xed, 0xd6, 0xcb, 0x57, 0x2f, 0xf7, 0xbe, 0x0d, 0x07, 0x63,
	0xfe, 0x94, 0x56, 0xb6, 0x21, 0x8c, 0x53, 0xb3, 0xdf, 0x17, 0x43, 0x8d, 0xa9, 0x80, 0x3f, 0x23,
	0x07, 0x0b, 0xc1, 0x68, 0x77, 0x30, 0xa9, 0xb4, 0xa5, 0x42, 0xbb, 0xcb, 0x9f, 0x93, 0x4b, 0x1e,
	0xc4, 0x75, 0x4e, 0xbd, 0x9b, 0x83, 0x91, 0x32, 0x7c, 0xfe, 0x88, 0xf6, 0x61, 0x43, 0x6c, 0x07,
	0xd6, 0x0f, 0x82, 0xc8, 0x3b, 0x1b, 0xe0, 0xee, 0xaf, 0xf6, 0xbd, 0x28, 0xbe, 0x4f, 0x1b, 0x34,
	0xdd, 0xd4, 0x3e, 0xdc, 0xdb, 0x89, 0xbc, 0x3e, 0xf1, 0xb4, 0x08, 0xfb, 0x63, 0xfe, 0x63, 0xb3,
	0xb7, 0x0c, 0x61, 0x5f, 0xc3, 0x93, 0xdf, 0x8a, 0x33, 0x2b, 0x60, 0x22, 0xd4, 0x41, 0xdf, 0xd3,
	0x22, 0xa2, 0xd3, 0x3a, 0x34, 0xe0, 0x2e, 0x17, 0xe7, 0x2f, 0x25, 0xa8, 0x21, 0xf1, 0x27, 0x41,
	0xa4, 0xcd, 0xc3, 0xa1, 0x0e, 0x95, 0xf4, 0x7a, 0xc6, 0x59, 0x30, 0xbd, 0x9b, 0x5f, 0xc0, 0xf2,
	0x91, 0xd4, 0x2d, 0xa1, 0x74, 0xf0, 0x81, 0x26, 0xa1, 0x64, 0x58, 0x71, 0x0b, 0x28, 0xbd, 0x58,
	0xb0, 0x06, 0xf9, 0xc4, 0xe9, 0x8c, 0xd9, 0x77, 0x86, 0x20, 0x5b, 0x99, 0xd5, 0xa5, 0xa4, 0x58,
	0x71, 0x6d, 0xc8, 0x79, 0x65, 0x76, 0x81, 0xdb, 0x62, 0x3f, 0x87, 0x39, 0x6c, 0x27, 0xef, 0x05,
	0xeb, 0x1d, 0x92, 0xdb, 0xb9, 0x6b, 0xbc, 0x9c, 0x03, 0xa8, 0x60, 0x4d, 0xc1, 0xd7, 0x07, 0xdb,
	0x9b, 0x78, 0x4a, 0x3f, 0x2d, 0xbe, 0x62, 0xec, 0xa7, 0x77, 0xf6, 0x9c, 0x76, 0x7e, 0x05, 0x8f,
	0xcc, 0x65, 0x1d, 0x29, 0xd1, 0x51, 0xf2, 0x4c, 0xa8, 0xa4, 0x4c, 0x18, 0x41, 0x9c, 0x09, 0x15,
	0x93, 0x1a, 0xff, 0x09, 0xca, 0x83, 0xce, 0x5f, 0xcb, 0x00, 0xbd, 0x56, 0x27, 0xae, 0xf3, 0x78,
	0xe2, 0x37, 0xe1, 0x99, 0x1c, 0x85, 0x3e, 0x95, 0x01, 0x53, 0x7f, 0x6d, 0xc8, 0x2a, 0x67, 0x65,
	0xda, 0xe8, 0x3d, 0xcb, 0x19, 0xfe, 0x15, 0x22, 0x29, 0x7e, 0x3b, 0xd2, 0xd9, 0xfc, 0xe6, 0x4d,
	0x30, 0xd9, 0x81, 0x85, 0x96, 0xc0, 0x42, 0x49, 0xaa, 0xb9, 0x45, 0xb8, 0xe0, 0x49, 0xf7, 0xd6,
	0x54, 0xa6, 0x22, 0x8c, 0x8a, 0xe9, 0x08, 0xa1, 0xac, 0x47, 0x53, 0x6a, 0x27, 0x7d, 0xb4, 0xd0,
	0x82, 0x79, 0x50, 0x24, 0xb6, 0xb3, 0x0f, 0xcb, 0x19, 0x43, 0x14, 0xe9, 0x06, 0x54, 0x62, 0x33,
	0x09, 0xf6, 0x7a, 0xc6, 0x42, 0xe6, 0xeb, 0xa6, 0x5e, 0xce, 0x3f, 0x4a, 0x34, 0xc9, 0xa9, 0xc8,
	0x1e, 0xae, 0x53, 0x09, 0x29, 0xdd, 0x46, 0x48, 0xd1, 0x9b, 0x4e, 0x61, 0x4a, 0xfc, 0x64, 0xc7,
	0x34, 0xfa, 0x66, 0xee, 0x4d, 0xdf, 0xec, 0x54, 0xfa, 0x76, 0x7e, 0x07, 0x2b, 0x07, 0xf2, 0x3a,
	0x1c, 0x48, 0xcf, 0x37, 0x8a, 0x14, 0x8a, 0x1d, 0xe2, 0x93, 0x1f, 0xdb, 0x74, 0x5d, 0x6e, 0x7b,
	0x79, 0xd7, 0xef, 0x14, 0x73, 0xa3, 0xb4, 0xf3, 0xaf, 0x79, 0x78, 0x70, 0xbc, 0x73, 0x44, 0x2b,
	0x26, 0x2f, 0x89, 0x53, 0x58, 0xb2, 0x3f, 0x1d, 0xb0, 0x67, 0xd6, 0x4b, 0x6d, 0xf2, 0x4b, 0x43,
	0xfd, 0xf9, 0x6d, 0xdd, 0xf1, 0xeb, 0xf2, 0x2d, 0x2c, 0x5a, 0xdf, 0x08, 0x98, 0xb5, 0xa3, 0xc9,
	0x8f, 0x0d, 0xf5, 0x67, 0xb7, 0xf4, 0xa6, 0x73, 0x2d, 0xd9, 0x1f, 0x0a, 0xec, 0xad, 0x4d, 0xf9,
	0x80, 0x50, 0x7f, 0x32, 0xa5, 0x3b, 0x9d, 0xeb, 0x04, 0x6a, 0xb9, 0x6b, 0xc3, 0xfe, 0xc3, 0x7d,
	0xba, 0x7b, 0xb6, 0x9f, 0x42, 0xf5, 0x48, 0xe8, 0xf8, 0x8c, 0x4b, 0xdb, 0xf1, 0x27, 0x9a, 0xef,
	0x64, 0xe0, 0xd7, 0x73, 0x2f, 0x5d, 0xea, 0x7f, 0x09, 0xb5, 0x23, 0xa1, 0xbf, 0x09, 0xe5, 0x75,
	0x48, 0x19, 0xa9, 0x30, 0x80, 0x4d, 0xe6, 0x2f, 0x0c, 0xca, 0x7e, 0x60, 0x45, 0xfc, 0xc9, 0xf4,
	0xc0, 0xde, 0x23, 0xea, 0x9b, 0xa5, 0x46, 0xe9, 0xff, 0x24, 0x1f, 0xf6, 0x1a, 0xaa, 0x94, 0x93,
	0x8f, 0x7b, 0xa7, 0x27, 0xec, 0x91, 0xe5, 0x6c, 0xfd, 0x9f, 0xab, 0x3f, 0x9e, 0xc0, 0x63, 0xce,
	0xf6, 0x60, 0x8e, 0x80, 0xff, 0x7e, 0x64, 0x13, 0x1e, 0x14, 0x72, 0x2f, 0xdb, 0x28, 0xb2, 0x5c,
	0x4c, 0xcb, 0xf5, 0x1c, 0xc9, 0xec, 0x35, 0xc0, 0x91, 0xd0, 0x71, 0x66, 0x60, 0x3c, 0x97, 0x45,
	0xac, 0x64, 0x51, 0x9f, 0x9a, 0x5f, 0xd8, 0x1e, 0x2c, 0x9b, 0xd1, 0x49, 0x9e, 0x29, 0x84, 0x90,
	0x4f, 0x1b, 0x85, 0x81, 0xdc, 0x7f, 0x0b, 0x9f, 0x87, 0x42, 0xdb, 0x9f, 0xf7, 0xe2, 0x0f, 0x7e,
	0xde, 0x30, 0x88, 0xd2, 0x51, 0xdf, 0x7f, 0x7e, 0x8f, 0x8f, 0x88, 0x67, 0xf3, 0xf4, 0x09, 0xf0,
	0xcb, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff, 0x1d, 0xe8, 0xc4, 0xaf, 0x79, 0x14, 0x00, 0x00,
}
