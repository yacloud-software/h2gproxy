// Code generated by protoc-gen-go.
// source: protos/golang.conradwood.net/apis/h2gproxy/h2gproxy.proto
// DO NOT EDIT!

/*
Package h2gproxy is a generated protocol buffer package.

It is generated from these files:
	protos/golang.conradwood.net/apis/h2gproxy/h2gproxy.proto

It has these top-level messages:
	CreateConfigRequest
	CreateConfigResponse
	ApplyConfigRequest
	ApplyConfigResponse
	AddConfigResponse
	AddConfigTCPRequest
	TCPStart
	Header
	Parameter
	WebSocketRequest
	WebSocketResponse
	BiStreamRequest
	StreamData
	BiStreamResponse
	StreamDataResponse
	StreamRequest
	StreamResponse
	StreamDataRequest
	ServeRequest
	Cookie
	ServeResponse
	Config
	AddConfigHTTPRequest
	RedirectRewrite
	HostListEntry
	HostList
	BodyData
	ConfigureProberRequest
	TCPProxy
	ConfigFile
	GlobalConfig
	TCPSession
	TCPSessionList
	TCPMetaRequest
*/
package h2gproxy

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CreateConfigRequest struct {
}

func (m *CreateConfigRequest) Reset()                    { *m = CreateConfigRequest{} }
func (m *CreateConfigRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateConfigRequest) ProtoMessage()               {}
func (*CreateConfigRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type CreateConfigResponse struct {
	ConfigID string `protobuf:"bytes,1,opt,name=ConfigID" json:"ConfigID,omitempty"`
}

func (m *CreateConfigResponse) Reset()                    { *m = CreateConfigResponse{} }
func (m *CreateConfigResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateConfigResponse) ProtoMessage()               {}
func (*CreateConfigResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *CreateConfigResponse) GetConfigID() string {
	if m != nil {
		return m.ConfigID
	}
	return ""
}

type ApplyConfigRequest struct {
	ConfigID string `protobuf:"bytes,1,opt,name=ConfigID" json:"ConfigID,omitempty"`
}

func (m *ApplyConfigRequest) Reset()                    { *m = ApplyConfigRequest{} }
func (m *ApplyConfigRequest) String() string            { return proto.CompactTextString(m) }
func (*ApplyConfigRequest) ProtoMessage()               {}
func (*ApplyConfigRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ApplyConfigRequest) GetConfigID() string {
	if m != nil {
		return m.ConfigID
	}
	return ""
}

type ApplyConfigResponse struct {
	Applied bool `protobuf:"varint,1,opt,name=Applied" json:"Applied,omitempty"`
}

func (m *ApplyConfigResponse) Reset()                    { *m = ApplyConfigResponse{} }
func (m *ApplyConfigResponse) String() string            { return proto.CompactTextString(m) }
func (*ApplyConfigResponse) ProtoMessage()               {}
func (*ApplyConfigResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ApplyConfigResponse) GetApplied() bool {
	if m != nil {
		return m.Applied
	}
	return false
}

type AddConfigResponse struct {
}

func (m *AddConfigResponse) Reset()                    { *m = AddConfigResponse{} }
func (m *AddConfigResponse) String() string            { return proto.CompactTextString(m) }
func (*AddConfigResponse) ProtoMessage()               {}
func (*AddConfigResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type AddConfigTCPRequest struct {
	ConfigID          string `protobuf:"bytes,1,opt,name=ConfigID" json:"ConfigID,omitempty"`
	SourcePort        int32  `protobuf:"varint,2,opt,name=SourcePort" json:"SourcePort,omitempty"`
	TargetServicePath string `protobuf:"bytes,3,opt,name=TargetServicePath" json:"TargetServicePath,omitempty"`
	KeepAliveSeconds  uint32 `protobuf:"varint,4,opt,name=KeepAliveSeconds" json:"KeepAliveSeconds,omitempty"`
	AddHeaderToTCP    bool   `protobuf:"varint,5,opt,name=AddHeaderToTCP" json:"AddHeaderToTCP,omitempty"`
	EnableTLS         bool   `protobuf:"varint,6,opt,name=EnableTLS" json:"EnableTLS,omitempty"`
	TLSSubject        string `protobuf:"bytes,7,opt,name=TLSSubject" json:"TLSSubject,omitempty"`
	NeedAuth          bool   `protobuf:"varint,8,opt,name=NeedAuth" json:"NeedAuth,omitempty"`
}

func (m *AddConfigTCPRequest) Reset()                    { *m = AddConfigTCPRequest{} }
func (m *AddConfigTCPRequest) String() string            { return proto.CompactTextString(m) }
func (*AddConfigTCPRequest) ProtoMessage()               {}
func (*AddConfigTCPRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *AddConfigTCPRequest) GetConfigID() string {
	if m != nil {
		return m.ConfigID
	}
	return ""
}

func (m *AddConfigTCPRequest) GetSourcePort() int32 {
	if m != nil {
		return m.SourcePort
	}
	return 0
}

func (m *AddConfigTCPRequest) GetTargetServicePath() string {
	if m != nil {
		return m.TargetServicePath
	}
	return ""
}

func (m *AddConfigTCPRequest) GetKeepAliveSeconds() uint32 {
	if m != nil {
		return m.KeepAliveSeconds
	}
	return 0
}

func (m *AddConfigTCPRequest) GetAddHeaderToTCP() bool {
	if m != nil {
		return m.AddHeaderToTCP
	}
	return false
}

func (m *AddConfigTCPRequest) GetEnableTLS() bool {
	if m != nil {
		return m.EnableTLS
	}
	return false
}

func (m *AddConfigTCPRequest) GetTLSSubject() string {
	if m != nil {
		return m.TLSSubject
	}
	return ""
}

func (m *AddConfigTCPRequest) GetNeedAuth() bool {
	if m != nil {
		return m.NeedAuth
	}
	return false
}

type TCPStart struct {
	ConnectionID string `protobuf:"bytes,1,opt,name=ConnectionID" json:"ConnectionID,omitempty"`
	RemoteIP     string `protobuf:"bytes,2,opt,name=RemoteIP" json:"RemoteIP,omitempty"`
	RemotePort   uint32 `protobuf:"varint,3,opt,name=RemotePort" json:"RemotePort,omitempty"`
	LocalIP      string `protobuf:"bytes,4,opt,name=LocalIP" json:"LocalIP,omitempty"`
	LocalPort    uint32 `protobuf:"varint,5,opt,name=LocalPort" json:"LocalPort,omitempty"`
}

func (m *TCPStart) Reset()                    { *m = TCPStart{} }
func (m *TCPStart) String() string            { return proto.CompactTextString(m) }
func (*TCPStart) ProtoMessage()               {}
func (*TCPStart) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *TCPStart) GetConnectionID() string {
	if m != nil {
		return m.ConnectionID
	}
	return ""
}

func (m *TCPStart) GetRemoteIP() string {
	if m != nil {
		return m.RemoteIP
	}
	return ""
}

func (m *TCPStart) GetRemotePort() uint32 {
	if m != nil {
		return m.RemotePort
	}
	return 0
}

func (m *TCPStart) GetLocalIP() string {
	if m != nil {
		return m.LocalIP
	}
	return ""
}

func (m *TCPStart) GetLocalPort() uint32 {
	if m != nil {
		return m.LocalPort
	}
	return 0
}

// ******************************************************
// gRPC Proxies must serve this
// ******************************************************
type Header struct {
	Name   string   `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Values []string `protobuf:"bytes,2,rep,name=Values" json:"Values,omitempty"`
}

func (m *Header) Reset()                    { *m = Header{} }
func (m *Header) String() string            { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()               {}
func (*Header) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Header) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Header) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

type Parameter struct {
	Name  string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=Value" json:"Value,omitempty"`
}

func (m *Parameter) Reset()                    { *m = Parameter{} }
func (m *Parameter) String() string            { return proto.CompactTextString(m) }
func (*Parameter) ProtoMessage()               {}
func (*Parameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Parameter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Parameter) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type WebSocketRequest struct {
	Frame []byte `protobuf:"bytes,1,opt,name=Frame,proto3" json:"Frame,omitempty"`
}

func (m *WebSocketRequest) Reset()                    { *m = WebSocketRequest{} }
func (m *WebSocketRequest) String() string            { return proto.CompactTextString(m) }
func (*WebSocketRequest) ProtoMessage()               {}
func (*WebSocketRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *WebSocketRequest) GetFrame() []byte {
	if m != nil {
		return m.Frame
	}
	return nil
}

type WebSocketResponse struct {
	Frame []byte `protobuf:"bytes,1,opt,name=Frame,proto3" json:"Frame,omitempty"`
}

func (m *WebSocketResponse) Reset()                    { *m = WebSocketResponse{} }
func (m *WebSocketResponse) String() string            { return proto.CompactTextString(m) }
func (*WebSocketResponse) ProtoMessage()               {}
func (*WebSocketResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *WebSocketResponse) GetFrame() []byte {
	if m != nil {
		return m.Frame
	}
	return nil
}

type BiStreamRequest struct {
	HTTPRequest *StreamRequest `protobuf:"bytes,1,opt,name=HTTPRequest" json:"HTTPRequest,omitempty"`
	Data        *StreamData    `protobuf:"bytes,2,opt,name=Data" json:"Data,omitempty"`
}

func (m *BiStreamRequest) Reset()                    { *m = BiStreamRequest{} }
func (m *BiStreamRequest) String() string            { return proto.CompactTextString(m) }
func (*BiStreamRequest) ProtoMessage()               {}
func (*BiStreamRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *BiStreamRequest) GetHTTPRequest() *StreamRequest {
	if m != nil {
		return m.HTTPRequest
	}
	return nil
}

func (m *BiStreamRequest) GetData() *StreamData {
	if m != nil {
		return m.Data
	}
	return nil
}

type StreamData struct {
	Key      string `protobuf:"bytes,1,opt,name=Key" json:"Key,omitempty"`
	Filename string `protobuf:"bytes,2,opt,name=Filename" json:"Filename,omitempty"`
	Data     []byte `protobuf:"bytes,3,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *StreamData) Reset()                    { *m = StreamData{} }
func (m *StreamData) String() string            { return proto.CompactTextString(m) }
func (*StreamData) ProtoMessage()               {}
func (*StreamData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *StreamData) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *StreamData) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *StreamData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type BiStreamResponse struct {
	HTTPResponse *StreamResponse `protobuf:"bytes,1,opt,name=HTTPResponse" json:"HTTPResponse,omitempty"`
	Data         []byte          `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *BiStreamResponse) Reset()                    { *m = BiStreamResponse{} }
func (m *BiStreamResponse) String() string            { return proto.CompactTextString(m) }
func (*BiStreamResponse) ProtoMessage()               {}
func (*BiStreamResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *BiStreamResponse) GetHTTPResponse() *StreamResponse {
	if m != nil {
		return m.HTTPResponse
	}
	return nil
}

func (m *BiStreamResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type StreamDataResponse struct {
	Response *StreamResponse `protobuf:"bytes,1,opt,name=Response" json:"Response,omitempty"`
	Data     []byte          `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *StreamDataResponse) Reset()                    { *m = StreamDataResponse{} }
func (m *StreamDataResponse) String() string            { return proto.CompactTextString(m) }
func (*StreamDataResponse) ProtoMessage()               {}
func (*StreamDataResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *StreamDataResponse) GetResponse() *StreamResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *StreamDataResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// stream backends receive this from h2gproxy
type StreamRequest struct {
	Headers    []*Header    `protobuf:"bytes,1,rep,name=Headers" json:"Headers,omitempty"`
	Path       string       `protobuf:"bytes,3,opt,name=Path" json:"Path,omitempty"`
	Method     string       `protobuf:"bytes,4,opt,name=Method" json:"Method,omitempty"`
	Parameters []*Parameter `protobuf:"bytes,5,rep,name=Parameters" json:"Parameters,omitempty"`
	Host       string       `protobuf:"bytes,6,opt,name=Host" json:"Host,omitempty"`
	UserAgent  string       `protobuf:"bytes,7,opt,name=UserAgent" json:"UserAgent,omitempty"`
	SourceIP   string       `protobuf:"bytes,8,opt,name=SourceIP" json:"SourceIP,omitempty"`
	Query      string       `protobuf:"bytes,9,opt,name=Query" json:"Query,omitempty"`
	Port       uint32       `protobuf:"varint,10,opt,name=Port" json:"Port,omitempty"`
}

func (m *StreamRequest) Reset()                    { *m = StreamRequest{} }
func (m *StreamRequest) String() string            { return proto.CompactTextString(m) }
func (*StreamRequest) ProtoMessage()               {}
func (*StreamRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *StreamRequest) GetHeaders() []*Header {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *StreamRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *StreamRequest) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *StreamRequest) GetParameters() []*Parameter {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *StreamRequest) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *StreamRequest) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

func (m *StreamRequest) GetSourceIP() string {
	if m != nil {
		return m.SourceIP
	}
	return ""
}

func (m *StreamRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *StreamRequest) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// stream backends send this to H2GProxy
type StreamResponse struct {
	Filename     string            `protobuf:"bytes,1,opt,name=Filename" json:"Filename,omitempty"`
	Size         uint64            `protobuf:"varint,2,opt,name=Size" json:"Size,omitempty"`
	MimeType     string            `protobuf:"bytes,3,opt,name=MimeType" json:"MimeType,omitempty"`
	ExtraHeaders map[string]string `protobuf:"bytes,4,rep,name=ExtraHeaders" json:"ExtraHeaders,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	StatusCode   uint32            `protobuf:"varint,5,opt,name=StatusCode" json:"StatusCode,omitempty"`
}

func (m *StreamResponse) Reset()                    { *m = StreamResponse{} }
func (m *StreamResponse) String() string            { return proto.CompactTextString(m) }
func (*StreamResponse) ProtoMessage()               {}
func (*StreamResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *StreamResponse) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *StreamResponse) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *StreamResponse) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *StreamResponse) GetExtraHeaders() map[string]string {
	if m != nil {
		return m.ExtraHeaders
	}
	return nil
}

func (m *StreamResponse) GetStatusCode() uint32 {
	if m != nil {
		return m.StatusCode
	}
	return 0
}

type StreamDataRequest struct {
	Request *StreamRequest `protobuf:"bytes,1,opt,name=Request" json:"Request,omitempty"`
	Data    []byte         `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *StreamDataRequest) Reset()                    { *m = StreamDataRequest{} }
func (m *StreamDataRequest) String() string            { return proto.CompactTextString(m) }
func (*StreamDataRequest) ProtoMessage()               {}
func (*StreamDataRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *StreamDataRequest) GetRequest() *StreamRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *StreamDataRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// unary backends receive this from h2gproxy
type ServeRequest struct {
	Headers      []*Header    `protobuf:"bytes,1,rep,name=Headers" json:"Headers,omitempty"`
	Body         string       `protobuf:"bytes,2,opt,name=Body" json:"Body,omitempty"`
	Path         string       `protobuf:"bytes,3,opt,name=Path" json:"Path,omitempty"`
	Method       string       `protobuf:"bytes,4,opt,name=Method" json:"Method,omitempty"`
	Parameters   []*Parameter `protobuf:"bytes,5,rep,name=Parameters" json:"Parameters,omitempty"`
	Host         string       `protobuf:"bytes,6,opt,name=Host" json:"Host,omitempty"`
	UserAgent    string       `protobuf:"bytes,7,opt,name=UserAgent" json:"UserAgent,omitempty"`
	SourceIP     string       `protobuf:"bytes,8,opt,name=SourceIP" json:"SourceIP,omitempty"`
	SessionToken string       `protobuf:"bytes,9,opt,name=SessionToken" json:"SessionToken,omitempty"`
}

func (m *ServeRequest) Reset()                    { *m = ServeRequest{} }
func (m *ServeRequest) String() string            { return proto.CompactTextString(m) }
func (*ServeRequest) ProtoMessage()               {}
func (*ServeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *ServeRequest) GetHeaders() []*Header {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *ServeRequest) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func (m *ServeRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *ServeRequest) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *ServeRequest) GetParameters() []*Parameter {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *ServeRequest) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *ServeRequest) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

func (m *ServeRequest) GetSourceIP() string {
	if m != nil {
		return m.SourceIP
	}
	return ""
}

func (m *ServeRequest) GetSessionToken() string {
	if m != nil {
		return m.SessionToken
	}
	return ""
}

type Cookie struct {
	Name   string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Value  string `protobuf:"bytes,2,opt,name=Value" json:"Value,omitempty"`
	Expiry uint32 `protobuf:"varint,3,opt,name=Expiry" json:"Expiry,omitempty"`
}

func (m *Cookie) Reset()                    { *m = Cookie{} }
func (m *Cookie) String() string            { return proto.CompactTextString(m) }
func (*Cookie) ProtoMessage()               {}
func (*Cookie) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *Cookie) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Cookie) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Cookie) GetExpiry() uint32 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

type ServeResponse struct {
	HTTPResponseCode uint32 `protobuf:"varint,1,opt,name=HTTPResponseCode" json:"HTTPResponseCode,omitempty"`
	GRPCCode         uint32 `protobuf:"varint,2,opt,name=GRPCCode" json:"GRPCCode,omitempty"`
	//  string OBSOLETE_Text = 3;    // Deprecated!! the response to be served to the client
	MimeType        string    `protobuf:"bytes,4,opt,name=MimeType" json:"MimeType,omitempty"`
	Cookies         []*Cookie `protobuf:"bytes,5,rep,name=Cookies" json:"Cookies,omitempty"`
	Body            []byte    `protobuf:"bytes,6,opt,name=Body,proto3" json:"Body,omitempty"`
	RedirectToSlash bool      `protobuf:"varint,7,opt,name=RedirectToSlash" json:"RedirectToSlash,omitempty"`
}

func (m *ServeResponse) Reset()                    { *m = ServeResponse{} }
func (m *ServeResponse) String() string            { return proto.CompactTextString(m) }
func (*ServeResponse) ProtoMessage()               {}
func (*ServeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *ServeResponse) GetHTTPResponseCode() uint32 {
	if m != nil {
		return m.HTTPResponseCode
	}
	return 0
}

func (m *ServeResponse) GetGRPCCode() uint32 {
	if m != nil {
		return m.GRPCCode
	}
	return 0
}

func (m *ServeResponse) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *ServeResponse) GetCookies() []*Cookie {
	if m != nil {
		return m.Cookies
	}
	return nil
}

func (m *ServeResponse) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *ServeResponse) GetRedirectToSlash() bool {
	if m != nil {
		return m.RedirectToSlash
	}
	return false
}

type Config struct {
	Config []*AddConfigHTTPRequest `protobuf:"bytes,1,rep,name=Config" json:"Config,omitempty"`
}

func (m *Config) Reset()                    { *m = Config{} }
func (m *Config) String() string            { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()               {}
func (*Config) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *Config) GetConfig() []*AddConfigHTTPRequest {
	if m != nil {
		return m.Config
	}
	return nil
}

//
// A configuration of an http endpoint
type AddConfigHTTPRequest struct {
	ConfigID string `protobuf:"bytes,1,opt,name=ConfigID" json:"ConfigID,omitempty"`
	// the url snippet to match on
	URLPath string `protobuf:"bytes,2,opt,name=URLPath" json:"URLPath,omitempty"`
	// (we need either target or service)
	// the optional url to forward to
	TargetHost string `protobuf:"bytes,3,opt,name=TargetHost" json:"TargetHost,omitempty"`
	TargetPort int32  `protobuf:"varint,4,opt,name=TargetPort" json:"TargetPort,omitempty"`
	// the service address to forward to
	TargetService string `protobuf:"bytes,5,opt,name=TargetService" json:"TargetService,omitempty"`
	// we might need to rewrite the URL a bit to match what the target expects
	TargetURL string `protobuf:"bytes,6,opt,name=TargetURL" json:"TargetURL,omitempty"`
	// me might need to set a specific host header to get what we want
	TargetHostname string `protobuf:"bytes,7,opt,name=TargetHostname" json:"TargetHostname,omitempty"`
	// we strip the urlpath out of the request before
	// passing it to the backend
	// we optionally may insert this prefix
	PathPrefix string `protobuf:"bytes,8,opt,name=PathPrefix" json:"PathPrefix,omitempty"`
	// and we might need random stupid headers
	Header []string `protobuf:"bytes,9,rep,name=Header" json:"Header,omitempty"`
	// if true, proxy will enforce authentication
	// before proxying to the target
	NeedAuth bool `protobuf:"varint,10,opt,name=NeedAuth" json:"NeedAuth,omitempty"`
	// for this entry to match, user must be in any of these groups
	// if empty - any AUTHENTICATED request matches
	Groups []string `protobuf:"bytes,11,rep,name=Groups" json:"Groups,omitempty"`
	// same as groups, but for users :)
	Users []string `protobuf:"bytes,12,rep,name=Users" json:"Users,omitempty"`
	// if empty will match all hosts
	URLHostname string `protobuf:"bytes,13,opt,name=URLHostname" json:"URLHostname,omitempty"`
	// either "ip" or "hostname"(default)
	ForwardedFor string `protobuf:"bytes,14,opt,name=ForwardedFor" json:"ForwardedFor,omitempty"`
	// if non-nil 500 errors will be intercepted and a webpage served instead
	ErrorPage500 string `protobuf:"bytes,15,opt,name=ErrorPage500" json:"ErrorPage500,omitempty"`
	// if non-nil 400 errors will be intercepted and a webpage served instead
	ErrorPage400 string `protobuf:"bytes,16,opt,name=ErrorPage400" json:"ErrorPage400,omitempty"`
	// send a "fake" Authorization header to the backend? (e.g. gerrit needs this)
	// an "Authorization:" header will be added to each request to the backend, encoding
	// either the userid or the username (see UseUserNameForFakeAuth)
	SendFakeAuthorization bool `protobuf:"varint,17,opt,name=SendFakeAuthorization" json:"SendFakeAuthorization,omitempty"`
	// if nil, it'll set the original host as requested by the client. override if
	// necessary
	// special: set it to "targethost" and it will be set to whatever targethost
	// matched
	ForwardedHost string `protobuf:"bytes,18,opt,name=ForwardedHost" json:"ForwardedHost,omitempty"`
	// a name made up to identify this entry by humans
	// e.g. for statistics and/or debugging
	ConfigName string `protobuf:"bytes,19,opt,name=ConfigName" json:"ConfigName,omitempty"`
	// if empty - matches any protocol
	// otherwise http/https
	ProtocolRequired string `protobuf:"bytes,20,opt,name=ProtocolRequired" json:"ProtocolRequired,omitempty"`
	// allow authorization headers to be passed to the backend (e.g. hes needs
	// this)
	// this is potentially a very dangerous option - enable with caution
	AllowAuthorizationFromClient bool `protobuf:"varint,21,opt,name=AllowAuthorizationFromClient" json:"AllowAuthorizationFromClient,omitempty"`
	// another dangerous option: enable basic auth from the backend,
	// bypassing SSO altogether. Use with caution!
	ForceBackendAuthorization bool `protobuf:"varint,22,opt,name=ForceBackendAuthorization" json:"ForceBackendAuthorization,omitempty"`
	// max requests "in flights" (== currently processing) for
	// this backend (total over all instances)
	// additional requests past this limit are dropped with error
	MaxInFlights int32 `protobuf:"varint,23,opt,name=MaxInFlights" json:"MaxInFlights,omitempty"`
	//
	// if "none" (0) h2gproxy will forward http requests to http-only backends (no grpc)<br/>
	//
	// if "json" (1) h2gproxy will parse the form and forward via grpc to json-api-multiplexer backend<br/>
	//
	// if "html" (2) h2gproxy will parse the form and forward via grpc to htmlserver backend<br/>
	//
	// if "weblogin" (3) h2gproxy will parse the form and forward via grpc to weblogin backend<br/>
	//
	// if "download" (4) h2gproxy will forward to (any specified) streaming grpc api backend<br/>
	//
	// if "proxy" (5) h2gproxy will forward to (any specified) streaming grpc proxying api backend with raw http information. An entry of this type will match if URLHostname matches partially. Security risk (see readme!)<br/>
	//
	// if "bistream" (6) (EXPERIMENTAL) h2gproxy will use a bidirectional grpc stream to forward the client's request to a grpc server and stream the response back to the client. This is useful for file uploads or image converters or other large file exchanges. For files, it requires the client's request to be encoded with "multipart/form-data".
	ApiType string `protobuf:"bytes,24,opt,name=ApiType" json:"ApiType,omitempty"`
	// if true h2gproxy will intercept Redirect (301) from backends and rewrite them
	// to match what the client sent (mainly for the many broken web frameworks out there)
	RewriteRedirectHost bool `protobuf:"varint,25,opt,name=RewriteRedirectHost" json:"RewriteRedirectHost,omitempty"`
	// choose between ["id"/"email"/"abbrev"] with FakeBackendAuthorization
	UserNameForFakeAuth string `protobuf:"bytes,26,opt,name=UserNameForFakeAuth" json:"UserNameForFakeAuth,omitempty"`
	// max amount of requests per second
	MaxPerSec uint32 `protobuf:"varint,27,opt,name=MaxPerSec" json:"MaxPerSec,omitempty"`
	// this will only match if request comes from private ip
	RFC1918Only bool `protobuf:"varint,28,opt,name=RFC1918Only" json:"RFC1918Only,omitempty"`
	// normally, if we have a valid certificate for a hostname which
	// a client requests via http, then we will automatically send a
	// redirect to the corresponding https location
	// with this option set to true we will serve the content over http
	// instead
	AcceptHTTP bool `protobuf:"varint,29,opt,name=AcceptHTTP" json:"AcceptHTTP,omitempty"`
	// if we proxy a host (targethost), we normally use http (unless it's on port 443)
	// this option will make it use https instead
	ProxyForHTTPS bool `protobuf:"varint,30,opt,name=ProxyForHTTPS" json:"ProxyForHTTPS,omitempty"`
	// how many seconds might this request run before timingout (context deadline)
	MaxDuration uint32 `protobuf:"varint,31,opt,name=MaxDuration" json:"MaxDuration,omitempty"`
	// for certain configurations, such as apis or proxies we might only want to do basic auth or tokens or
	DisableFormBasedAuth bool `protobuf:"varint,32,opt,name=DisableFormBasedAuth" json:"DisableFormBasedAuth,omitempty"`
	LowLatency           bool `protobuf:"varint,33,opt,name=LowLatency" json:"LowLatency,omitempty"`
	// only applicable to apitype web, if backend sends 401/403 it will be passed to the client. h2gproxy thus will never be in the path to authenticate user. This can be useful for the many broken webframeworks, as typically found in php, python(django/uwsgi/foo)
	WebBackendAuthenticatesOnly bool `protobuf:"varint,34,opt,name=WebBackendAuthenticatesOnly" json:"WebBackendAuthenticatesOnly,omitempty"`
	// if non empty, INCOMING requests' URLs will be matched, rewritten and a 307 redirect sent
	RedirectRewrites []*RedirectRewrite `protobuf:"bytes,36,rep,name=RedirectRewrites" json:"RedirectRewrites,omitempty"`
	// if true, h2gproxy will redirect any requests without a sessioncookie to weblogin to get a session
	SessionRequired bool `protobuf:"varint,38,opt,name=SessionRequired" json:"SessionRequired,omitempty"`
	// if true, will serve with local certificate only
	LocalTLSCertificateOnly bool `protobuf:"varint,39,opt,name=LocalTLSCertificateOnly" json:"LocalTLSCertificateOnly,omitempty"`
}

func (m *AddConfigHTTPRequest) Reset()                    { *m = AddConfigHTTPRequest{} }
func (m *AddConfigHTTPRequest) String() string            { return proto.CompactTextString(m) }
func (*AddConfigHTTPRequest) ProtoMessage()               {}
func (*AddConfigHTTPRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *AddConfigHTTPRequest) GetConfigID() string {
	if m != nil {
		return m.ConfigID
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetURLPath() string {
	if m != nil {
		return m.URLPath
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetTargetHost() string {
	if m != nil {
		return m.TargetHost
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetTargetPort() int32 {
	if m != nil {
		return m.TargetPort
	}
	return 0
}

func (m *AddConfigHTTPRequest) GetTargetService() string {
	if m != nil {
		return m.TargetService
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetTargetURL() string {
	if m != nil {
		return m.TargetURL
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetTargetHostname() string {
	if m != nil {
		return m.TargetHostname
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetPathPrefix() string {
	if m != nil {
		return m.PathPrefix
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetHeader() []string {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *AddConfigHTTPRequest) GetNeedAuth() bool {
	if m != nil {
		return m.NeedAuth
	}
	return false
}

func (m *AddConfigHTTPRequest) GetGroups() []string {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *AddConfigHTTPRequest) GetUsers() []string {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *AddConfigHTTPRequest) GetURLHostname() string {
	if m != nil {
		return m.URLHostname
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetForwardedFor() string {
	if m != nil {
		return m.ForwardedFor
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetErrorPage500() string {
	if m != nil {
		return m.ErrorPage500
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetErrorPage400() string {
	if m != nil {
		return m.ErrorPage400
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetSendFakeAuthorization() bool {
	if m != nil {
		return m.SendFakeAuthorization
	}
	return false
}

func (m *AddConfigHTTPRequest) GetForwardedHost() string {
	if m != nil {
		return m.ForwardedHost
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetConfigName() string {
	if m != nil {
		return m.ConfigName
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetProtocolRequired() string {
	if m != nil {
		return m.ProtocolRequired
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetAllowAuthorizationFromClient() bool {
	if m != nil {
		return m.AllowAuthorizationFromClient
	}
	return false
}

func (m *AddConfigHTTPRequest) GetForceBackendAuthorization() bool {
	if m != nil {
		return m.ForceBackendAuthorization
	}
	return false
}

func (m *AddConfigHTTPRequest) GetMaxInFlights() int32 {
	if m != nil {
		return m.MaxInFlights
	}
	return 0
}

func (m *AddConfigHTTPRequest) GetApiType() string {
	if m != nil {
		return m.ApiType
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetRewriteRedirectHost() bool {
	if m != nil {
		return m.RewriteRedirectHost
	}
	return false
}

func (m *AddConfigHTTPRequest) GetUserNameForFakeAuth() string {
	if m != nil {
		return m.UserNameForFakeAuth
	}
	return ""
}

func (m *AddConfigHTTPRequest) GetMaxPerSec() uint32 {
	if m != nil {
		return m.MaxPerSec
	}
	return 0
}

func (m *AddConfigHTTPRequest) GetRFC1918Only() bool {
	if m != nil {
		return m.RFC1918Only
	}
	return false
}

func (m *AddConfigHTTPRequest) GetAcceptHTTP() bool {
	if m != nil {
		return m.AcceptHTTP
	}
	return false
}

func (m *AddConfigHTTPRequest) GetProxyForHTTPS() bool {
	if m != nil {
		return m.ProxyForHTTPS
	}
	return false
}

func (m *AddConfigHTTPRequest) GetMaxDuration() uint32 {
	if m != nil {
		return m.MaxDuration
	}
	return 0
}

func (m *AddConfigHTTPRequest) GetDisableFormBasedAuth() bool {
	if m != nil {
		return m.DisableFormBasedAuth
	}
	return false
}

func (m *AddConfigHTTPRequest) GetLowLatency() bool {
	if m != nil {
		return m.LowLatency
	}
	return false
}

func (m *AddConfigHTTPRequest) GetWebBackendAuthenticatesOnly() bool {
	if m != nil {
		return m.WebBackendAuthenticatesOnly
	}
	return false
}

func (m *AddConfigHTTPRequest) GetRedirectRewrites() []*RedirectRewrite {
	if m != nil {
		return m.RedirectRewrites
	}
	return nil
}

func (m *AddConfigHTTPRequest) GetSessionRequired() bool {
	if m != nil {
		return m.SessionRequired
	}
	return false
}

func (m *AddConfigHTTPRequest) GetLocalTLSCertificateOnly() bool {
	if m != nil {
		return m.LocalTLSCertificateOnly
	}
	return false
}

// definition on how INBOUND request urls are rewritten and redirected
type RedirectRewrite struct {
	MatchString string `protobuf:"bytes,1,opt,name=MatchString" json:"MatchString,omitempty"`
	ReplaceWith string `protobuf:"bytes,2,opt,name=ReplaceWith" json:"ReplaceWith,omitempty"`
	SetHost     string `protobuf:"bytes,3,opt,name=SetHost" json:"SetHost,omitempty"`
}

func (m *RedirectRewrite) Reset()                    { *m = RedirectRewrite{} }
func (m *RedirectRewrite) String() string            { return proto.CompactTextString(m) }
func (*RedirectRewrite) ProtoMessage()               {}
func (*RedirectRewrite) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *RedirectRewrite) GetMatchString() string {
	if m != nil {
		return m.MatchString
	}
	return ""
}

func (m *RedirectRewrite) GetReplaceWith() string {
	if m != nil {
		return m.ReplaceWith
	}
	return ""
}

func (m *RedirectRewrite) GetSetHost() string {
	if m != nil {
		return m.SetHost
	}
	return ""
}

type HostListEntry struct {
	Hostname       string `protobuf:"bytes,1,opt,name=Hostname" json:"Hostname,omitempty"`
	GotCertificate bool   `protobuf:"varint,2,opt,name=GotCertificate" json:"GotCertificate,omitempty"`
	ServedHTTP     bool   `protobuf:"varint,3,opt,name=ServedHTTP" json:"ServedHTTP,omitempty"`
	ServedHTTPS    bool   `protobuf:"varint,4,opt,name=ServedHTTPS" json:"ServedHTTPS,omitempty"`
}

func (m *HostListEntry) Reset()                    { *m = HostListEntry{} }
func (m *HostListEntry) String() string            { return proto.CompactTextString(m) }
func (*HostListEntry) ProtoMessage()               {}
func (*HostListEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *HostListEntry) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *HostListEntry) GetGotCertificate() bool {
	if m != nil {
		return m.GotCertificate
	}
	return false
}

func (m *HostListEntry) GetServedHTTP() bool {
	if m != nil {
		return m.ServedHTTP
	}
	return false
}

func (m *HostListEntry) GetServedHTTPS() bool {
	if m != nil {
		return m.ServedHTTPS
	}
	return false
}

type HostList struct {
	Hosts []*HostListEntry `protobuf:"bytes,1,rep,name=Hosts" json:"Hosts,omitempty"`
}

func (m *HostList) Reset()                    { *m = HostList{} }
func (m *HostList) String() string            { return proto.CompactTextString(m) }
func (*HostList) ProtoMessage()               {}
func (*HostList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *HostList) GetHosts() []*HostListEntry {
	if m != nil {
		return m.Hosts
	}
	return nil
}

type BodyData struct {
	Response *StreamDataResponse `protobuf:"bytes,1,opt,name=Response" json:"Response,omitempty"`
}

func (m *BodyData) Reset()                    { *m = BodyData{} }
func (m *BodyData) String() string            { return proto.CompactTextString(m) }
func (*BodyData) ProtoMessage()               {}
func (*BodyData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *BodyData) GetResponse() *StreamDataResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type ConfigureProberRequest struct {
	ProberBackend bool `protobuf:"varint,1,opt,name=ProberBackend" json:"ProberBackend,omitempty"`
}

func (m *ConfigureProberRequest) Reset()                    { *m = ConfigureProberRequest{} }
func (m *ConfigureProberRequest) String() string            { return proto.CompactTextString(m) }
func (*ConfigureProberRequest) ProtoMessage()               {}
func (*ConfigureProberRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *ConfigureProberRequest) GetProberBackend() bool {
	if m != nil {
		return m.ProberBackend
	}
	return false
}

type TCPProxy struct {
	Port             uint32 `protobuf:"varint,1,opt,name=Port" json:"Port,omitempty"`
	Target           string `protobuf:"bytes,2,opt,name=Target" json:"Target,omitempty"`
	KeepAliveSeconds uint32 `protobuf:"varint,3,opt,name=KeepAliveSeconds" json:"KeepAliveSeconds,omitempty"`
	AddHeaderToTCP   bool   `protobuf:"varint,5,opt,name=AddHeaderToTCP" json:"AddHeaderToTCP,omitempty"`
}

func (m *TCPProxy) Reset()                    { *m = TCPProxy{} }
func (m *TCPProxy) String() string            { return proto.CompactTextString(m) }
func (*TCPProxy) ProtoMessage()               {}
func (*TCPProxy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *TCPProxy) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *TCPProxy) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *TCPProxy) GetKeepAliveSeconds() uint32 {
	if m != nil {
		return m.KeepAliveSeconds
	}
	return 0
}

func (m *TCPProxy) GetAddHeaderToTCP() bool {
	if m != nil {
		return m.AddHeaderToTCP
	}
	return false
}

// defines the syntax of the config file
type ConfigFile struct {
	Tcpproxy     []*TCPProxy             `protobuf:"bytes,1,rep,name=Tcpproxy" json:"Tcpproxy,omitempty"`
	Httpproxy    []*AddConfigHTTPRequest `protobuf:"bytes,2,rep,name=Httpproxy" json:"Httpproxy,omitempty"`
	GlobalConfig *GlobalConfig           `protobuf:"bytes,3,opt,name=GlobalConfig" json:"GlobalConfig,omitempty"`
}

func (m *ConfigFile) Reset()                    { *m = ConfigFile{} }
func (m *ConfigFile) String() string            { return proto.CompactTextString(m) }
func (*ConfigFile) ProtoMessage()               {}
func (*ConfigFile) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *ConfigFile) GetTcpproxy() []*TCPProxy {
	if m != nil {
		return m.Tcpproxy
	}
	return nil
}

func (m *ConfigFile) GetHttpproxy() []*AddConfigHTTPRequest {
	if m != nil {
		return m.Httpproxy
	}
	return nil
}

func (m *ConfigFile) GetGlobalConfig() *GlobalConfig {
	if m != nil {
		return m.GlobalConfig
	}
	return nil
}

type GlobalConfig struct {
	DebugHeaderGroups []string `protobuf:"bytes,1,rep,name=DebugHeaderGroups" json:"DebugHeaderGroups,omitempty"`
}

func (m *GlobalConfig) Reset()                    { *m = GlobalConfig{} }
func (m *GlobalConfig) String() string            { return proto.CompactTextString(m) }
func (*GlobalConfig) ProtoMessage()               {}
func (*GlobalConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *GlobalConfig) GetDebugHeaderGroups() []string {
	if m != nil {
		return m.DebugHeaderGroups
	}
	return nil
}

type TCPSession struct {
	// the port an external client connects to. This is what h2gproxy listens on
	InboundPort uint32 `protobuf:"varint,1,opt,name=InboundPort" json:"InboundPort,omitempty"`
	// the config attached to the inbound port
	Config *AddConfigHTTPRequest `protobuf:"bytes,2,opt,name=Config" json:"Config,omitempty"`
	// the ephemeral port assigned by the OS for the connection to the proxy target
	ProxyOutboundPort uint32 `protobuf:"varint,3,opt,name=ProxyOutboundPort" json:"ProxyOutboundPort,omitempty"`
	// the target we connected this session to
	ProxyTargetPort uint32 `protobuf:"varint,4,opt,name=ProxyTargetPort" json:"ProxyTargetPort,omitempty"`
	// the target we connected this session to
	ProxyTargetHost string `protobuf:"bytes,5,opt,name=ProxyTargetHost" json:"ProxyTargetHost,omitempty"`
	PeerHost        string `protobuf:"bytes,6,opt,name=PeerHost" json:"PeerHost,omitempty"`
	PeerPort        uint32 `protobuf:"varint,7,opt,name=PeerPort" json:"PeerPort,omitempty"`
}

func (m *TCPSession) Reset()                    { *m = TCPSession{} }
func (m *TCPSession) String() string            { return proto.CompactTextString(m) }
func (*TCPSession) ProtoMessage()               {}
func (*TCPSession) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *TCPSession) GetInboundPort() uint32 {
	if m != nil {
		return m.InboundPort
	}
	return 0
}

func (m *TCPSession) GetConfig() *AddConfigHTTPRequest {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *TCPSession) GetProxyOutboundPort() uint32 {
	if m != nil {
		return m.ProxyOutboundPort
	}
	return 0
}

func (m *TCPSession) GetProxyTargetPort() uint32 {
	if m != nil {
		return m.ProxyTargetPort
	}
	return 0
}

func (m *TCPSession) GetProxyTargetHost() string {
	if m != nil {
		return m.ProxyTargetHost
	}
	return ""
}

func (m *TCPSession) GetPeerHost() string {
	if m != nil {
		return m.PeerHost
	}
	return ""
}

func (m *TCPSession) GetPeerPort() uint32 {
	if m != nil {
		return m.PeerPort
	}
	return 0
}

type TCPSessionList struct {
	Sessions []*TCPSession `protobuf:"bytes,1,rep,name=Sessions" json:"Sessions,omitempty"`
}

func (m *TCPSessionList) Reset()                    { *m = TCPSessionList{} }
func (m *TCPSessionList) String() string            { return proto.CompactTextString(m) }
func (*TCPSessionList) ProtoMessage()               {}
func (*TCPSessionList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *TCPSessionList) GetSessions() []*TCPSession {
	if m != nil {
		return m.Sessions
	}
	return nil
}

//
// TCP defines a connection by {IP1, Port1, IP2, Port2 }. This means, it is possible (albeit in practice not
// wide spread) that a ProxyOutboundPort is reused if connecting to different instances.
// this is the connection in the datacenter
type TCPMetaRequest struct {
	ProxyOutboundPort uint32 `protobuf:"varint,1,opt,name=ProxyOutboundPort" json:"ProxyOutboundPort,omitempty"`
	ProxyOutboundHost string `protobuf:"bytes,2,opt,name=ProxyOutboundHost" json:"ProxyOutboundHost,omitempty"`
	ProxyTargetPort   uint32 `protobuf:"varint,3,opt,name=ProxyTargetPort" json:"ProxyTargetPort,omitempty"`
	ProxyTargetHost   string `protobuf:"bytes,4,opt,name=ProxyTargetHost" json:"ProxyTargetHost,omitempty"`
}

func (m *TCPMetaRequest) Reset()                    { *m = TCPMetaRequest{} }
func (m *TCPMetaRequest) String() string            { return proto.CompactTextString(m) }
func (*TCPMetaRequest) ProtoMessage()               {}
func (*TCPMetaRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *TCPMetaRequest) GetProxyOutboundPort() uint32 {
	if m != nil {
		return m.ProxyOutboundPort
	}
	return 0
}

func (m *TCPMetaRequest) GetProxyOutboundHost() string {
	if m != nil {
		return m.ProxyOutboundHost
	}
	return ""
}

func (m *TCPMetaRequest) GetProxyTargetPort() uint32 {
	if m != nil {
		return m.ProxyTargetPort
	}
	return 0
}

func (m *TCPMetaRequest) GetProxyTargetHost() string {
	if m != nil {
		return m.ProxyTargetHost
	}
	return ""
}

func init() {
	proto.RegisterType((*CreateConfigRequest)(nil), "h2gproxy.CreateConfigRequest")
	proto.RegisterType((*CreateConfigResponse)(nil), "h2gproxy.CreateConfigResponse")
	proto.RegisterType((*ApplyConfigRequest)(nil), "h2gproxy.ApplyConfigRequest")
	proto.RegisterType((*ApplyConfigResponse)(nil), "h2gproxy.ApplyConfigResponse")
	proto.RegisterType((*AddConfigResponse)(nil), "h2gproxy.AddConfigResponse")
	proto.RegisterType((*AddConfigTCPRequest)(nil), "h2gproxy.AddConfigTCPRequest")
	proto.RegisterType((*TCPStart)(nil), "h2gproxy.TCPStart")
	proto.RegisterType((*Header)(nil), "h2gproxy.Header")
	proto.RegisterType((*Parameter)(nil), "h2gproxy.Parameter")
	proto.RegisterType((*WebSocketRequest)(nil), "h2gproxy.WebSocketRequest")
	proto.RegisterType((*WebSocketResponse)(nil), "h2gproxy.WebSocketResponse")
	proto.RegisterType((*BiStreamRequest)(nil), "h2gproxy.BiStreamRequest")
	proto.RegisterType((*StreamData)(nil), "h2gproxy.StreamData")
	proto.RegisterType((*BiStreamResponse)(nil), "h2gproxy.BiStreamResponse")
	proto.RegisterType((*StreamDataResponse)(nil), "h2gproxy.StreamDataResponse")
	proto.RegisterType((*StreamRequest)(nil), "h2gproxy.StreamRequest")
	proto.RegisterType((*StreamResponse)(nil), "h2gproxy.StreamResponse")
	proto.RegisterType((*StreamDataRequest)(nil), "h2gproxy.StreamDataRequest")
	proto.RegisterType((*ServeRequest)(nil), "h2gproxy.ServeRequest")
	proto.RegisterType((*Cookie)(nil), "h2gproxy.Cookie")
	proto.RegisterType((*ServeResponse)(nil), "h2gproxy.ServeResponse")
	proto.RegisterType((*Config)(nil), "h2gproxy.Config")
	proto.RegisterType((*AddConfigHTTPRequest)(nil), "h2gproxy.AddConfigHTTPRequest")
	proto.RegisterType((*RedirectRewrite)(nil), "h2gproxy.RedirectRewrite")
	proto.RegisterType((*HostListEntry)(nil), "h2gproxy.HostListEntry")
	proto.RegisterType((*HostList)(nil), "h2gproxy.HostList")
	proto.RegisterType((*BodyData)(nil), "h2gproxy.BodyData")
	proto.RegisterType((*ConfigureProberRequest)(nil), "h2gproxy.ConfigureProberRequest")
	proto.RegisterType((*TCPProxy)(nil), "h2gproxy.TCPProxy")
	proto.RegisterType((*ConfigFile)(nil), "h2gproxy.ConfigFile")
	proto.RegisterType((*GlobalConfig)(nil), "h2gproxy.GlobalConfig")
	proto.RegisterType((*TCPSession)(nil), "h2gproxy.TCPSession")
	proto.RegisterType((*TCPSessionList)(nil), "h2gproxy.TCPSessionList")
	proto.RegisterType((*TCPMetaRequest)(nil), "h2gproxy.TCPMetaRequest")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for WebsocketProxy service

type WebsocketProxyClient interface {
	WebSocketHTTP(ctx context.Context, opts ...grpc.CallOption) (WebsocketProxy_WebSocketHTTPClient, error)
}

type websocketProxyClient struct {
	cc *grpc.ClientConn
}

func NewWebsocketProxyClient(cc *grpc.ClientConn) WebsocketProxyClient {
	return &websocketProxyClient{cc}
}

func (c *websocketProxyClient) WebSocketHTTP(ctx context.Context, opts ...grpc.CallOption) (WebsocketProxy_WebSocketHTTPClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_WebsocketProxy_serviceDesc.Streams[0], c.cc, "/h2gproxy.WebsocketProxy/WebSocketHTTP", opts...)
	if err != nil {
		return nil, err
	}
	x := &websocketProxyWebSocketHTTPClient{stream}
	return x, nil
}

type WebsocketProxy_WebSocketHTTPClient interface {
	Send(*WebSocketRequest) error
	Recv() (*WebSocketResponse, error)
	grpc.ClientStream
}

type websocketProxyWebSocketHTTPClient struct {
	grpc.ClientStream
}

func (x *websocketProxyWebSocketHTTPClient) Send(m *WebSocketRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *websocketProxyWebSocketHTTPClient) Recv() (*WebSocketResponse, error) {
	m := new(WebSocketResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for WebsocketProxy service

type WebsocketProxyServer interface {
	WebSocketHTTP(WebsocketProxy_WebSocketHTTPServer) error
}

func RegisterWebsocketProxyServer(s *grpc.Server, srv WebsocketProxyServer) {
	s.RegisterService(&_WebsocketProxy_serviceDesc, srv)
}

func _WebsocketProxy_WebSocketHTTP_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WebsocketProxyServer).WebSocketHTTP(&websocketProxyWebSocketHTTPServer{stream})
}

type WebsocketProxy_WebSocketHTTPServer interface {
	Send(*WebSocketResponse) error
	Recv() (*WebSocketRequest, error)
	grpc.ServerStream
}

type websocketProxyWebSocketHTTPServer struct {
	grpc.ServerStream
}

func (x *websocketProxyWebSocketHTTPServer) Send(m *WebSocketResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *websocketProxyWebSocketHTTPServer) Recv() (*WebSocketRequest, error) {
	m := new(WebSocketRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _WebsocketProxy_serviceDesc = grpc.ServiceDesc{
	ServiceName: "h2gproxy.WebsocketProxy",
	HandlerType: (*WebsocketProxyServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WebSocketHTTP",
			Handler:       _WebsocketProxy_WebSocketHTTP_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "protos/golang.conradwood.net/apis/h2gproxy/h2gproxy.proto",
}

// Client API for BiDirectionalStreamer service

type BiDirectionalStreamerClient interface {
	StreamBiHTTP(ctx context.Context, opts ...grpc.CallOption) (BiDirectionalStreamer_StreamBiHTTPClient, error)
}

type biDirectionalStreamerClient struct {
	cc *grpc.ClientConn
}

func NewBiDirectionalStreamerClient(cc *grpc.ClientConn) BiDirectionalStreamerClient {
	return &biDirectionalStreamerClient{cc}
}

func (c *biDirectionalStreamerClient) StreamBiHTTP(ctx context.Context, opts ...grpc.CallOption) (BiDirectionalStreamer_StreamBiHTTPClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BiDirectionalStreamer_serviceDesc.Streams[0], c.cc, "/h2gproxy.BiDirectionalStreamer/StreamBiHTTP", opts...)
	if err != nil {
		return nil, err
	}
	x := &biDirectionalStreamerStreamBiHTTPClient{stream}
	return x, nil
}

type BiDirectionalStreamer_StreamBiHTTPClient interface {
	Send(*BiStreamRequest) error
	Recv() (*BiStreamResponse, error)
	grpc.ClientStream
}

type biDirectionalStreamerStreamBiHTTPClient struct {
	grpc.ClientStream
}

func (x *biDirectionalStreamerStreamBiHTTPClient) Send(m *BiStreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *biDirectionalStreamerStreamBiHTTPClient) Recv() (*BiStreamResponse, error) {
	m := new(BiStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for BiDirectionalStreamer service

type BiDirectionalStreamerServer interface {
	StreamBiHTTP(BiDirectionalStreamer_StreamBiHTTPServer) error
}

func RegisterBiDirectionalStreamerServer(s *grpc.Server, srv BiDirectionalStreamerServer) {
	s.RegisterService(&_BiDirectionalStreamer_serviceDesc, srv)
}

func _BiDirectionalStreamer_StreamBiHTTP_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BiDirectionalStreamerServer).StreamBiHTTP(&biDirectionalStreamerStreamBiHTTPServer{stream})
}

type BiDirectionalStreamer_StreamBiHTTPServer interface {
	Send(*BiStreamResponse) error
	Recv() (*BiStreamRequest, error)
	grpc.ServerStream
}

type biDirectionalStreamerStreamBiHTTPServer struct {
	grpc.ServerStream
}

func (x *biDirectionalStreamerStreamBiHTTPServer) Send(m *BiStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *biDirectionalStreamerStreamBiHTTPServer) Recv() (*BiStreamRequest, error) {
	m := new(BiStreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _BiDirectionalStreamer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "h2gproxy.BiDirectionalStreamer",
	HandlerType: (*BiDirectionalStreamerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamBiHTTP",
			Handler:       _BiDirectionalStreamer_StreamBiHTTP_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "protos/golang.conradwood.net/apis/h2gproxy/h2gproxy.proto",
}

// Client API for DownloadStreamer service

type DownloadStreamerClient interface {
	//
	// Implementors Note: There are two types of errors, that somewhat overlap:
	// 1. The backend service encounters an unhandled error
	// 2. The backend service is unable to locate a resource (e.g. URL returns 404)
	// The streaming proxy distinguishes between errors returned from the backend vs http codes indicated through stream response. Generally, if the backend suceeds, that is, the codepath goes through anticipated states, it should not throw an error, but indicate the status through its response instead. errors should be reserved for errors encountered by the backend itself. That is, don't just blindly wrap errors ;)
	StreamHTTP(ctx context.Context, in *StreamRequest, opts ...grpc.CallOption) (DownloadStreamer_StreamHTTPClient, error)
}

type downloadStreamerClient struct {
	cc *grpc.ClientConn
}

func NewDownloadStreamerClient(cc *grpc.ClientConn) DownloadStreamerClient {
	return &downloadStreamerClient{cc}
}

func (c *downloadStreamerClient) StreamHTTP(ctx context.Context, in *StreamRequest, opts ...grpc.CallOption) (DownloadStreamer_StreamHTTPClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DownloadStreamer_serviceDesc.Streams[0], c.cc, "/h2gproxy.DownloadStreamer/StreamHTTP", opts...)
	if err != nil {
		return nil, err
	}
	x := &downloadStreamerStreamHTTPClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DownloadStreamer_StreamHTTPClient interface {
	Recv() (*StreamDataResponse, error)
	grpc.ClientStream
}

type downloadStreamerStreamHTTPClient struct {
	grpc.ClientStream
}

func (x *downloadStreamerStreamHTTPClient) Recv() (*StreamDataResponse, error) {
	m := new(StreamDataResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for DownloadStreamer service

type DownloadStreamerServer interface {
	//
	// Implementors Note: There are two types of errors, that somewhat overlap:
	// 1. The backend service encounters an unhandled error
	// 2. The backend service is unable to locate a resource (e.g. URL returns 404)
	// The streaming proxy distinguishes between errors returned from the backend vs http codes indicated through stream response. Generally, if the backend suceeds, that is, the codepath goes through anticipated states, it should not throw an error, but indicate the status through its response instead. errors should be reserved for errors encountered by the backend itself. That is, don't just blindly wrap errors ;)
	StreamHTTP(*StreamRequest, DownloadStreamer_StreamHTTPServer) error
}

func RegisterDownloadStreamerServer(s *grpc.Server, srv DownloadStreamerServer) {
	s.RegisterService(&_DownloadStreamer_serviceDesc, srv)
}

func _DownloadStreamer_StreamHTTP_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DownloadStreamerServer).StreamHTTP(m, &downloadStreamerStreamHTTPServer{stream})
}

type DownloadStreamer_StreamHTTPServer interface {
	Send(*StreamDataResponse) error
	grpc.ServerStream
}

type downloadStreamerStreamHTTPServer struct {
	grpc.ServerStream
}

func (x *downloadStreamerStreamHTTPServer) Send(m *StreamDataResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _DownloadStreamer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "h2gproxy.DownloadStreamer",
	HandlerType: (*DownloadStreamerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamHTTP",
			Handler:       _DownloadStreamer_StreamHTTP_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protos/golang.conradwood.net/apis/h2gproxy/h2gproxy.proto",
}

// Client API for H2GProxyService service

type H2GProxyServiceClient interface {
	// create a new config. This doesn't affect current operation until apply is
	// called
	CreateConfig(ctx context.Context, in *CreateConfigRequest, opts ...grpc.CallOption) (*CreateConfigResponse, error)
	// this applies a new config
	ApplyConfig(ctx context.Context, in *ApplyConfigRequest, opts ...grpc.CallOption) (*ApplyConfigResponse, error)
	AddConfigTCP(ctx context.Context, in *AddConfigTCPRequest, opts ...grpc.CallOption) (*AddConfigResponse, error)
	AddConfigHTTP(ctx context.Context, in *AddConfigHTTPRequest, opts ...grpc.CallOption) (*AddConfigResponse, error)
	// get current config
	GetConfig(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*Config, error)
	// get all hosts for which we at least once successfully served something and/or for which we have a valid certificate
	GetKnownHosts(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*HostList, error)
	// implemented for probers
	BiStreamHTTP(ctx context.Context, opts ...grpc.CallOption) (H2GProxyService_BiStreamHTTPClient, error)
	// implemented for probers
	StreamHTTP(ctx context.Context, in *StreamRequest, opts ...grpc.CallOption) (H2GProxyService_StreamHTTPClient, error)
	// implemented for probers
	ServeHTML(ctx context.Context, in *ServeRequest, opts ...grpc.CallOption) (*ServeResponse, error)
	// implemented for probers
	Serve(ctx context.Context, in *ServeRequest, opts ...grpc.CallOption) (*ServeResponse, error)
	// switch prober backend on or off (useful if a running h2gproxy needs to be probed)
	// this rpc is limited to root users
	ConfigureProber(ctx context.Context, in *ConfigureProberRequest, opts ...grpc.CallOption) (*common.Void, error)
	// we can get some meta information about proxied tcp connections here
	GetTCPMeta(ctx context.Context, in *TCPMetaRequest, opts ...grpc.CallOption) (*TCPSession, error)
	// list of currently proxied tcp requests
	GetTCPSessions(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*TCPSessionList, error)
}

type h2GProxyServiceClient struct {
	cc *grpc.ClientConn
}

func NewH2GProxyServiceClient(cc *grpc.ClientConn) H2GProxyServiceClient {
	return &h2GProxyServiceClient{cc}
}

func (c *h2GProxyServiceClient) CreateConfig(ctx context.Context, in *CreateConfigRequest, opts ...grpc.CallOption) (*CreateConfigResponse, error) {
	out := new(CreateConfigResponse)
	err := grpc.Invoke(ctx, "/h2gproxy.H2GProxyService/CreateConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *h2GProxyServiceClient) ApplyConfig(ctx context.Context, in *ApplyConfigRequest, opts ...grpc.CallOption) (*ApplyConfigResponse, error) {
	out := new(ApplyConfigResponse)
	err := grpc.Invoke(ctx, "/h2gproxy.H2GProxyService/ApplyConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *h2GProxyServiceClient) AddConfigTCP(ctx context.Context, in *AddConfigTCPRequest, opts ...grpc.CallOption) (*AddConfigResponse, error) {
	out := new(AddConfigResponse)
	err := grpc.Invoke(ctx, "/h2gproxy.H2GProxyService/AddConfigTCP", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *h2GProxyServiceClient) AddConfigHTTP(ctx context.Context, in *AddConfigHTTPRequest, opts ...grpc.CallOption) (*AddConfigResponse, error) {
	out := new(AddConfigResponse)
	err := grpc.Invoke(ctx, "/h2gproxy.H2GProxyService/AddConfigHTTP", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *h2GProxyServiceClient) GetConfig(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*Config, error) {
	out := new(Config)
	err := grpc.Invoke(ctx, "/h2gproxy.H2GProxyService/GetConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *h2GProxyServiceClient) GetKnownHosts(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*HostList, error) {
	out := new(HostList)
	err := grpc.Invoke(ctx, "/h2gproxy.H2GProxyService/GetKnownHosts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *h2GProxyServiceClient) BiStreamHTTP(ctx context.Context, opts ...grpc.CallOption) (H2GProxyService_BiStreamHTTPClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_H2GProxyService_serviceDesc.Streams[0], c.cc, "/h2gproxy.H2GProxyService/BiStreamHTTP", opts...)
	if err != nil {
		return nil, err
	}
	x := &h2GProxyServiceBiStreamHTTPClient{stream}
	return x, nil
}

type H2GProxyService_BiStreamHTTPClient interface {
	Send(*StreamDataRequest) error
	Recv() (*StreamDataResponse, error)
	grpc.ClientStream
}

type h2GProxyServiceBiStreamHTTPClient struct {
	grpc.ClientStream
}

func (x *h2GProxyServiceBiStreamHTTPClient) Send(m *StreamDataRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *h2GProxyServiceBiStreamHTTPClient) Recv() (*StreamDataResponse, error) {
	m := new(StreamDataResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *h2GProxyServiceClient) StreamHTTP(ctx context.Context, in *StreamRequest, opts ...grpc.CallOption) (H2GProxyService_StreamHTTPClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_H2GProxyService_serviceDesc.Streams[1], c.cc, "/h2gproxy.H2GProxyService/StreamHTTP", opts...)
	if err != nil {
		return nil, err
	}
	x := &h2GProxyServiceStreamHTTPClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type H2GProxyService_StreamHTTPClient interface {
	Recv() (*StreamDataResponse, error)
	grpc.ClientStream
}

type h2GProxyServiceStreamHTTPClient struct {
	grpc.ClientStream
}

func (x *h2GProxyServiceStreamHTTPClient) Recv() (*StreamDataResponse, error) {
	m := new(StreamDataResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *h2GProxyServiceClient) ServeHTML(ctx context.Context, in *ServeRequest, opts ...grpc.CallOption) (*ServeResponse, error) {
	out := new(ServeResponse)
	err := grpc.Invoke(ctx, "/h2gproxy.H2GProxyService/ServeHTML", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *h2GProxyServiceClient) Serve(ctx context.Context, in *ServeRequest, opts ...grpc.CallOption) (*ServeResponse, error) {
	out := new(ServeResponse)
	err := grpc.Invoke(ctx, "/h2gproxy.H2GProxyService/Serve", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *h2GProxyServiceClient) ConfigureProber(ctx context.Context, in *ConfigureProberRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/h2gproxy.H2GProxyService/ConfigureProber", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *h2GProxyServiceClient) GetTCPMeta(ctx context.Context, in *TCPMetaRequest, opts ...grpc.CallOption) (*TCPSession, error) {
	out := new(TCPSession)
	err := grpc.Invoke(ctx, "/h2gproxy.H2GProxyService/GetTCPMeta", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *h2GProxyServiceClient) GetTCPSessions(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*TCPSessionList, error) {
	out := new(TCPSessionList)
	err := grpc.Invoke(ctx, "/h2gproxy.H2GProxyService/GetTCPSessions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for H2GProxyService service

type H2GProxyServiceServer interface {
	// create a new config. This doesn't affect current operation until apply is
	// called
	CreateConfig(context.Context, *CreateConfigRequest) (*CreateConfigResponse, error)
	// this applies a new config
	ApplyConfig(context.Context, *ApplyConfigRequest) (*ApplyConfigResponse, error)
	AddConfigTCP(context.Context, *AddConfigTCPRequest) (*AddConfigResponse, error)
	AddConfigHTTP(context.Context, *AddConfigHTTPRequest) (*AddConfigResponse, error)
	// get current config
	GetConfig(context.Context, *common.Void) (*Config, error)
	// get all hosts for which we at least once successfully served something and/or for which we have a valid certificate
	GetKnownHosts(context.Context, *common.Void) (*HostList, error)
	// implemented for probers
	BiStreamHTTP(H2GProxyService_BiStreamHTTPServer) error
	// implemented for probers
	StreamHTTP(*StreamRequest, H2GProxyService_StreamHTTPServer) error
	// implemented for probers
	ServeHTML(context.Context, *ServeRequest) (*ServeResponse, error)
	// implemented for probers
	Serve(context.Context, *ServeRequest) (*ServeResponse, error)
	// switch prober backend on or off (useful if a running h2gproxy needs to be probed)
	// this rpc is limited to root users
	ConfigureProber(context.Context, *ConfigureProberRequest) (*common.Void, error)
	// we can get some meta information about proxied tcp connections here
	GetTCPMeta(context.Context, *TCPMetaRequest) (*TCPSession, error)
	// list of currently proxied tcp requests
	GetTCPSessions(context.Context, *common.Void) (*TCPSessionList, error)
}

func RegisterH2GProxyServiceServer(s *grpc.Server, srv H2GProxyServiceServer) {
	s.RegisterService(&_H2GProxyService_serviceDesc, srv)
}

func _H2GProxyService_CreateConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(H2GProxyServiceServer).CreateConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/h2gproxy.H2GProxyService/CreateConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(H2GProxyServiceServer).CreateConfig(ctx, req.(*CreateConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _H2GProxyService_ApplyConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(H2GProxyServiceServer).ApplyConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/h2gproxy.H2GProxyService/ApplyConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(H2GProxyServiceServer).ApplyConfig(ctx, req.(*ApplyConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _H2GProxyService_AddConfigTCP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddConfigTCPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(H2GProxyServiceServer).AddConfigTCP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/h2gproxy.H2GProxyService/AddConfigTCP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(H2GProxyServiceServer).AddConfigTCP(ctx, req.(*AddConfigTCPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _H2GProxyService_AddConfigHTTP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddConfigHTTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(H2GProxyServiceServer).AddConfigHTTP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/h2gproxy.H2GProxyService/AddConfigHTTP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(H2GProxyServiceServer).AddConfigHTTP(ctx, req.(*AddConfigHTTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _H2GProxyService_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(H2GProxyServiceServer).GetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/h2gproxy.H2GProxyService/GetConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(H2GProxyServiceServer).GetConfig(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _H2GProxyService_GetKnownHosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(H2GProxyServiceServer).GetKnownHosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/h2gproxy.H2GProxyService/GetKnownHosts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(H2GProxyServiceServer).GetKnownHosts(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _H2GProxyService_BiStreamHTTP_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(H2GProxyServiceServer).BiStreamHTTP(&h2GProxyServiceBiStreamHTTPServer{stream})
}

type H2GProxyService_BiStreamHTTPServer interface {
	Send(*StreamDataResponse) error
	Recv() (*StreamDataRequest, error)
	grpc.ServerStream
}

type h2GProxyServiceBiStreamHTTPServer struct {
	grpc.ServerStream
}

func (x *h2GProxyServiceBiStreamHTTPServer) Send(m *StreamDataResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *h2GProxyServiceBiStreamHTTPServer) Recv() (*StreamDataRequest, error) {
	m := new(StreamDataRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _H2GProxyService_StreamHTTP_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(H2GProxyServiceServer).StreamHTTP(m, &h2GProxyServiceStreamHTTPServer{stream})
}

type H2GProxyService_StreamHTTPServer interface {
	Send(*StreamDataResponse) error
	grpc.ServerStream
}

type h2GProxyServiceStreamHTTPServer struct {
	grpc.ServerStream
}

func (x *h2GProxyServiceStreamHTTPServer) Send(m *StreamDataResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _H2GProxyService_ServeHTML_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(H2GProxyServiceServer).ServeHTML(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/h2gproxy.H2GProxyService/ServeHTML",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(H2GProxyServiceServer).ServeHTML(ctx, req.(*ServeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _H2GProxyService_Serve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(H2GProxyServiceServer).Serve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/h2gproxy.H2GProxyService/Serve",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(H2GProxyServiceServer).Serve(ctx, req.(*ServeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _H2GProxyService_ConfigureProber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureProberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(H2GProxyServiceServer).ConfigureProber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/h2gproxy.H2GProxyService/ConfigureProber",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(H2GProxyServiceServer).ConfigureProber(ctx, req.(*ConfigureProberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _H2GProxyService_GetTCPMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TCPMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(H2GProxyServiceServer).GetTCPMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/h2gproxy.H2GProxyService/GetTCPMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(H2GProxyServiceServer).GetTCPMeta(ctx, req.(*TCPMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _H2GProxyService_GetTCPSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(H2GProxyServiceServer).GetTCPSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/h2gproxy.H2GProxyService/GetTCPSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(H2GProxyServiceServer).GetTCPSessions(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

var _H2GProxyService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "h2gproxy.H2GProxyService",
	HandlerType: (*H2GProxyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateConfig",
			Handler:    _H2GProxyService_CreateConfig_Handler,
		},
		{
			MethodName: "ApplyConfig",
			Handler:    _H2GProxyService_ApplyConfig_Handler,
		},
		{
			MethodName: "AddConfigTCP",
			Handler:    _H2GProxyService_AddConfigTCP_Handler,
		},
		{
			MethodName: "AddConfigHTTP",
			Handler:    _H2GProxyService_AddConfigHTTP_Handler,
		},
		{
			MethodName: "GetConfig",
			Handler:    _H2GProxyService_GetConfig_Handler,
		},
		{
			MethodName: "GetKnownHosts",
			Handler:    _H2GProxyService_GetKnownHosts_Handler,
		},
		{
			MethodName: "ServeHTML",
			Handler:    _H2GProxyService_ServeHTML_Handler,
		},
		{
			MethodName: "Serve",
			Handler:    _H2GProxyService_Serve_Handler,
		},
		{
			MethodName: "ConfigureProber",
			Handler:    _H2GProxyService_ConfigureProber_Handler,
		},
		{
			MethodName: "GetTCPMeta",
			Handler:    _H2GProxyService_GetTCPMeta_Handler,
		},
		{
			MethodName: "GetTCPSessions",
			Handler:    _H2GProxyService_GetTCPSessions_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "BiStreamHTTP",
			Handler:       _H2GProxyService_BiStreamHTTP_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamHTTP",
			Handler:       _H2GProxyService_StreamHTTP_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protos/golang.conradwood.net/apis/h2gproxy/h2gproxy.proto",
}

func init() {
	proto.RegisterFile("protos/golang.conradwood.net/apis/h2gproxy/h2gproxy.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 2280 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xd4, 0x59, 0xcd, 0x72, 0x1b, 0xb9,
	0xf1, 0x2f, 0x92, 0xfa, 0x20, 0x5b, 0x94, 0x2c, 0x41, 0xb2, 0x3d, 0xa6, 0x3f, 0xfe, 0xfa, 0xcf,
	0x6e, 0x39, 0x8a, 0xb3, 0x91, 0x69, 0xae, 0x37, 0x25, 0x6f, 0xa9, 0x92, 0x95, 0x28, 0x51, 0x92,
	0x4d, 0x79, 0x99, 0x21, 0xbd, 0xae, 0xec, 0x61, 0xab, 0x86, 0x33, 0x30, 0x35, 0x11, 0x35, 0x60,
	0x30, 0xa0, 0x25, 0xee, 0x23, 0xa4, 0x2a, 0xb7, 0xe4, 0x9e, 0xe4, 0x9e, 0x6b, 0x6e, 0xa9, 0xca,
	0x8b, 0xe4, 0x19, 0xf2, 0x0a, 0x29, 0x34, 0x30, 0x33, 0x98, 0x21, 0xa5, 0x28, 0x1f, 0x97, 0x9c,
	0x38, 0xfd, 0x43, 0x37, 0xd0, 0xe8, 0x2f, 0x34, 0x40, 0x78, 0x35, 0xe2, 0x4c, 0xb0, 0xe8, 0xf9,
	0x80, 0x0d, 0xdd, 0x70, 0xb0, 0xed, 0xb1, 0x90, 0xbb, 0xfe, 0x25, 0x63, 0xfe, 0x76, 0x48, 0xc5,
	0x73, 0x77, 0x14, 0x44, 0xcf, 0xcf, 0x1a, 0x83, 0x11, 0x67, 0x57, 0x93, 0xe4, 0x63, 0x1b, 0x65,
	0x48, 0x39, 0xa6, 0x6b, 0xdb, 0x37, 0x48, 0x7b, 0xec, 0xe2, 0x82, 0x85, 0xfa, 0x47, 0x49, 0xda,
	0x77, 0x61, 0xbd, 0xc9, 0xa9, 0x2b, 0x68, 0x93, 0x85, 0x1f, 0x82, 0x81, 0x43, 0x7f, 0x35, 0xa6,
	0x91, 0xb0, 0x1b, 0xb0, 0x91, 0x85, 0xa3, 0x11, 0x0b, 0x23, 0x4a, 0x6a, 0x50, 0x56, 0xc8, 0xc9,
	0x81, 0x55, 0xd8, 0x2c, 0x6c, 0x55, 0x9c, 0x84, 0xb6, 0xeb, 0x40, 0xf6, 0x46, 0xa3, 0xe1, 0x24,
	0x33, 0xd3, 0x8d, 0x12, 0xcf, 0x61, 0x3d, 0x23, 0xa1, 0x17, 0xb1, 0x60, 0x51, 0xc2, 0x01, 0xf5,
	0x51, 0xa2, 0xec, 0xc4, 0xa4, 0xbd, 0x0e, 0x6b, 0x7b, 0xbe, 0x9f, 0x65, 0xb7, 0xff, 0x54, 0x84,
	0xf5, 0x04, 0xed, 0x35, 0x3b, 0xb7, 0x58, 0x99, 0x3c, 0x01, 0xe8, 0xb2, 0x31, 0xf7, 0x68, 0x87,
	0x71, 0x61, 0x15, 0x37, 0x0b, 0x5b, 0xf3, 0x8e, 0x81, 0x90, 0xcf, 0x60, 0xad, 0xe7, 0xf2, 0x01,
	0x15, 0x5d, 0xca, 0x3f, 0x06, 0x1e, 0xed, 0xb8, 0xe2, 0xcc, 0x2a, 0xe1, 0x24, 0xd3, 0x03, 0xe4,
	0x19, 0xac, 0xbe, 0xa1, 0x74, 0xb4, 0x37, 0x0c, 0x3e, 0xd2, 0x2e, 0xf5, 0x58, 0xe8, 0x47, 0xd6,
	0xdc, 0x66, 0x61, 0x6b, 0xd9, 0x99, 0xc2, 0xc9, 0x53, 0x58, 0xd9, 0xf3, 0xfd, 0x63, 0xea, 0xfa,
	0x94, 0xf7, 0x58, 0xaf, 0xd9, 0xb1, 0xe6, 0x71, 0x8f, 0x39, 0x94, 0x3c, 0x82, 0xca, 0x61, 0xe8,
	0xf6, 0x87, 0xb4, 0xd7, 0xee, 0x5a, 0x0b, 0xc8, 0x92, 0x02, 0x52, 0xff, 0x5e, 0xbb, 0xdb, 0x1d,
	0xf7, 0x7f, 0x49, 0x3d, 0x61, 0x2d, 0xa2, 0x62, 0x06, 0x22, 0xf7, 0xfe, 0x96, 0x52, 0x7f, 0x6f,
	0x2c, 0xce, 0xac, 0x32, 0x0a, 0x27, 0xb4, 0xfd, 0xc7, 0x02, 0x94, 0x7b, 0xcd, 0x4e, 0x57, 0xb8,
	0x5c, 0x10, 0x1b, 0xaa, 0x4d, 0x16, 0x86, 0xd4, 0x13, 0x01, 0x0b, 0x13, 0x43, 0x65, 0x30, 0x39,
	0x99, 0x43, 0x2f, 0x98, 0xa0, 0x27, 0x1d, 0x34, 0x55, 0xc5, 0x49, 0x68, 0xa9, 0x88, 0xfa, 0x46,
	0x43, 0x96, 0x70, 0xd3, 0x06, 0x22, 0x7d, 0xd9, 0x66, 0x9e, 0x3b, 0x3c, 0xe9, 0xa0, 0x45, 0x2a,
	0x4e, 0x4c, 0xca, 0x0d, 0xe2, 0x27, 0x0a, 0xce, 0xa3, 0x60, 0x0a, 0xd8, 0x2f, 0x61, 0x41, 0x59,
	0x83, 0x10, 0x98, 0x7b, 0xeb, 0x5e, 0x50, 0xad, 0x19, 0x7e, 0x93, 0x7b, 0xb0, 0xf0, 0x8d, 0x3b,
	0x1c, 0xd3, 0xc8, 0x2a, 0x6e, 0x96, 0xb6, 0x2a, 0x8e, 0xa6, 0xec, 0x2f, 0xa0, 0xd2, 0x71, 0xb9,
	0x7b, 0x41, 0xc5, 0x35, 0x82, 0x1b, 0x30, 0x8f, 0xac, 0x7a, 0x1f, 0x8a, 0xb0, 0xb7, 0x60, 0xf5,
	0x3d, 0xed, 0x77, 0x99, 0x77, 0x4e, 0x45, 0x1c, 0x3d, 0x1b, 0x30, 0xdf, 0xe2, 0xb1, 0x78, 0xd5,
	0x51, 0x84, 0xfd, 0x43, 0x58, 0x33, 0x38, 0x75, 0xbc, 0xce, 0x66, 0xfd, 0x08, 0x77, 0xf6, 0x83,
	0xae, 0xe0, 0xd4, 0xbd, 0x88, 0xe7, 0x7c, 0x05, 0x4b, 0xc7, 0xbd, 0x5e, 0x1c, 0xa0, 0xc8, 0xbe,
	0xd4, 0xb8, 0xbf, 0x9d, 0x24, 0x73, 0x86, 0xdb, 0x31, 0x79, 0xc9, 0x16, 0xcc, 0x1d, 0xb8, 0xc2,
	0x45, 0xbd, 0x97, 0x1a, 0x1b, 0x79, 0x19, 0x39, 0xe6, 0x20, 0x87, 0xfd, 0x16, 0x20, 0xc5, 0xc8,
	0x2a, 0x94, 0xde, 0xd0, 0x89, 0xb6, 0x81, 0xfc, 0x94, 0xde, 0x6c, 0x05, 0x43, 0x1a, 0x4a, 0x85,
	0xb5, 0x37, 0x63, 0x5a, 0x9a, 0x0c, 0x57, 0x29, 0xe1, 0x46, 0xd4, 0x7c, 0x3e, 0xac, 0xa6, 0xfb,
	0xd0, 0x3b, 0xde, 0x85, 0xaa, 0x52, 0x4e, 0xd1, 0x7a, 0x27, 0xd6, 0xf4, 0x4e, 0xd4, 0xb8, 0x93,
	0xe1, 0x4e, 0x56, 0x29, 0x1a, 0xab, 0x7c, 0x07, 0xc4, 0xd8, 0x49, 0xcc, 0xf9, 0x52, 0x46, 0xde,
	0x2d, 0xd7, 0x28, 0xdf, 0x38, 0xff, 0x6f, 0x8b, 0xb0, 0x9c, 0x75, 0xc6, 0x33, 0x58, 0x54, 0x11,
	0x16, 0x59, 0x85, 0xcd, 0xd2, 0xd6, 0x52, 0x63, 0x35, 0x9d, 0x5a, 0x0d, 0x38, 0x31, 0x83, 0x9c,
	0xd1, 0xa8, 0x00, 0xf8, 0x2d, 0x63, 0xf0, 0x94, 0x8a, 0x33, 0xe6, 0xeb, 0xc0, 0xd6, 0x14, 0xf9,
	0x1c, 0x20, 0x89, 0xc1, 0xc8, 0x9a, 0xc7, 0xa9, 0xd7, 0xd3, 0xa9, 0x93, 0x31, 0xc7, 0x60, 0x93,
	0x0b, 0x1c, 0xb3, 0x48, 0x60, 0xa2, 0x57, 0x1c, 0xfc, 0x96, 0x09, 0xf2, 0x2e, 0xa2, 0x7c, 0x6f,
	0x40, 0xc3, 0x38, 0xc5, 0x53, 0x40, 0xba, 0x51, 0xd5, 0xab, 0x93, 0x0e, 0x66, 0x78, 0xc5, 0x49,
	0x68, 0x19, 0x90, 0x3f, 0x1f, 0x53, 0x3e, 0xb1, 0x2a, 0x2a, 0xca, 0x91, 0xc0, 0x4d, 0xc8, 0x5c,
	0x03, 0xcc, 0x35, 0xfc, 0xb6, 0x7f, 0x53, 0x84, 0x95, 0x9c, 0x6f, 0xcd, 0xf8, 0x28, 0x4c, 0xc7,
	0x47, 0x37, 0xf8, 0x5e, 0xc5, 0xcd, 0x9c, 0x83, 0xdf, 0x92, 0xff, 0x34, 0xb8, 0xa0, 0xbd, 0xc9,
	0x88, 0x6a, 0xfb, 0x24, 0x34, 0x79, 0x0b, 0xd5, 0xc3, 0x2b, 0xc1, 0xdd, 0xd8, 0xd0, 0x73, 0x68,
	0x8d, 0x67, 0xd7, 0xf9, 0x70, 0xdb, 0x64, 0x3e, 0x0c, 0x05, 0x9f, 0x38, 0x19, 0x79, 0x2c, 0xdb,
	0xc2, 0x15, 0xe3, 0xa8, 0xc9, 0x7c, 0xaa, 0x8b, 0x86, 0x81, 0xd4, 0x7e, 0x06, 0x6b, 0x53, 0x53,
	0xc8, 0x14, 0x38, 0x4f, 0x53, 0xe0, 0x9c, 0x4e, 0xa4, 0x7d, 0x3e, 0x9a, 0x55, 0x00, 0x89, 0x2f,
	0x8b, 0x3b, 0x05, 0xfb, 0x5b, 0x58, 0x33, 0xc3, 0x50, 0x45, 0xca, 0x0b, 0x58, 0xbc, 0x65, 0xca,
	0xc6, 0x7c, 0x33, 0x43, 0xf0, 0x0f, 0x45, 0xa8, 0xca, 0x53, 0x83, 0xfe, 0x9b, 0x11, 0xb8, 0xcf,
	0xfc, 0x89, 0xd6, 0x18, 0xbf, 0xff, 0xd7, 0xa2, 0xd2, 0x96, 0xdb, 0x8f, 0xa2, 0x80, 0x85, 0x3d,
	0x76, 0x4e, 0x43, 0x1d, 0x9c, 0x19, 0xcc, 0x7e, 0x0d, 0x0b, 0x4d, 0xc6, 0xce, 0x03, 0x7a, 0xfb,
	0xea, 0x2d, 0xb7, 0x7c, 0x78, 0x35, 0x0a, 0xf8, 0x44, 0x1f, 0x3f, 0x9a, 0xb2, 0xff, 0x56, 0x80,
	0x65, 0x6d, 0x6f, 0x1d, 0xda, 0xcf, 0x60, 0xd5, 0x2c, 0x44, 0x18, 0x44, 0x05, 0x75, 0x4e, 0xe7,
	0x71, 0xb9, 0x93, 0x23, 0xa7, 0xd3, 0x44, 0x9e, 0x22, 0xf2, 0x24, 0x74, 0x26, 0xe4, 0xe7, 0x72,
	0x21, 0xff, 0x0c, 0x16, 0xd5, 0x0e, 0x62, 0x2b, 0x1b, 0x4e, 0x55, 0x03, 0x4e, 0xcc, 0x90, 0x38,
	0x75, 0x41, 0x45, 0x09, 0x3a, 0x75, 0x0b, 0xee, 0x38, 0xd4, 0x0f, 0x38, 0xf5, 0x44, 0x8f, 0x75,
	0x87, 0x6e, 0x74, 0x86, 0x56, 0x2e, 0x3b, 0x79, 0xd8, 0xfe, 0x4a, 0xda, 0x4a, 0xf6, 0x33, 0xe4,
	0x27, 0xf1, 0x97, 0x8e, 0xa3, 0x27, 0xe9, 0x92, 0x49, 0x63, 0x64, 0x1c, 0x26, 0x8e, 0xe6, 0xb6,
	0xff, 0xb2, 0x04, 0x1b, 0xb3, 0x18, 0x6e, 0x6c, 0x9d, 0x2c, 0x58, 0x7c, 0xe7, 0xb4, 0x31, 0xf0,
	0x94, 0x1b, 0x62, 0x12, 0x9b, 0x12, 0xec, 0x8d, 0x30, 0x68, 0x4a, 0xba, 0x29, 0x49, 0x90, 0x74,
	0x1c, 0xcb, 0xd0, 0x9c, 0x6a, 0xba, 0x52, 0x84, 0x7c, 0x0a, 0xcb, 0x99, 0xde, 0x0a, 0x13, 0xbc,
	0xe2, 0x64, 0x41, 0x19, 0x80, 0x0a, 0x78, 0xe7, 0xb4, 0x75, 0x64, 0xa6, 0x80, 0x6c, 0xaf, 0xd2,
	0x15, 0xb1, 0x86, 0xa9, 0x18, 0xcd, 0xa1, 0x52, 0x17, 0xa9, 0x73, 0x87, 0xd3, 0x0f, 0xc1, 0x95,
	0x0e, 0x55, 0x03, 0x91, 0x41, 0xa5, 0x52, 0xcf, 0xaa, 0xa8, 0x0e, 0x43, 0x77, 0x23, 0x66, 0x63,
	0x05, 0xd9, 0xc6, 0x4a, 0xca, 0x1c, 0x71, 0x36, 0x1e, 0x45, 0xd6, 0x92, 0x92, 0x51, 0x94, 0x0c,
	0x5b, 0x99, 0x21, 0x91, 0x55, 0x45, 0x58, 0x11, 0x64, 0x13, 0x96, 0xde, 0x39, 0xed, 0x44, 0xcd,
	0x65, 0x54, 0xc1, 0x84, 0x64, 0xc2, 0xb4, 0x18, 0xbf, 0x74, 0xb9, 0x4f, 0xfd, 0x16, 0xe3, 0xd6,
	0x8a, 0x4a, 0x18, 0x13, 0x93, 0x3c, 0x87, 0x9c, 0x33, 0xde, 0x71, 0x07, 0xf4, 0x8b, 0x7a, 0xdd,
	0xba, 0xa3, 0x78, 0x4c, 0x2c, 0xc3, 0xf3, 0xb2, 0x5e, 0xb7, 0x56, 0x73, 0x3c, 0x2f, 0xeb, 0x75,
	0xf2, 0x12, 0xee, 0x76, 0x69, 0xe8, 0xb7, 0xdc, 0x73, 0x2a, 0xf7, 0xc2, 0x78, 0xf0, 0xbd, 0x2b,
	0xdb, 0x3f, 0x6b, 0x0d, 0x37, 0x39, 0x7b, 0x50, 0x7a, 0x2c, 0xd1, 0x06, 0x9d, 0x4e, 0x94, 0xc7,
	0x32, 0xa0, 0xb4, 0xb5, 0x8a, 0x1e, 0x4c, 0xe8, 0x75, 0x65, 0xeb, 0x14, 0x91, 0x69, 0xd9, 0x91,
	0x97, 0x11, 0x8f, 0x0d, 0x65, 0x00, 0x06, 0x9c, 0xfa, 0xd6, 0x06, 0x72, 0x4d, 0xe1, 0x64, 0x1f,
	0x1e, 0xed, 0x0d, 0x87, 0xec, 0x32, 0xa3, 0x47, 0x8b, 0xb3, 0x8b, 0xe6, 0x30, 0x90, 0x15, 0xe9,
	0x2e, 0xaa, 0x7b, 0x23, 0x0f, 0xd9, 0x85, 0x07, 0x2d, 0xc6, 0x3d, 0xba, 0xef, 0x7a, 0xe7, 0x34,
	0xf4, 0xb3, 0xfb, 0xbd, 0x87, 0x13, 0x5c, 0xcf, 0x20, 0xad, 0x79, 0xea, 0x5e, 0x9d, 0x84, 0xad,
	0x61, 0x30, 0x38, 0x13, 0x91, 0x75, 0x1f, 0xe3, 0x38, 0x83, 0xa9, 0x1b, 0x4c, 0x80, 0xf5, 0xc1,
	0x52, 0x39, 0xa2, 0x49, 0x52, 0x87, 0x75, 0x87, 0x5e, 0xf2, 0x40, 0xd0, 0x38, 0x9d, 0xd1, 0x6e,
	0x0f, 0x70, 0xd5, 0x59, 0x43, 0x52, 0x42, 0x06, 0x8c, 0xb4, 0x54, 0x8b, 0xf1, 0xd8, 0x07, 0x56,
	0x0d, 0xe7, 0x9d, 0x35, 0x24, 0x33, 0xe4, 0xd4, 0xbd, 0xea, 0x50, 0xde, 0xa5, 0x9e, 0xf5, 0x50,
	0x75, 0xd6, 0x09, 0x20, 0xe3, 0xce, 0x69, 0x35, 0x5f, 0xbc, 0x7a, 0xb1, 0xf3, 0x75, 0x38, 0x9c,
	0x58, 0x8f, 0x70, 0x65, 0x13, 0x92, 0xfe, 0xda, 0xf3, 0x3c, 0x3a, 0x12, 0xb2, 0x24, 0x58, 0x8f,
	0x91, 0xc1, 0x40, 0xa4, 0xd7, 0x3b, 0xb2, 0xb8, 0xb4, 0x18, 0x97, 0x74, 0xd7, 0x7a, 0x82, 0x2c,
	0x59, 0x50, 0xae, 0x73, 0xea, 0x5e, 0x1d, 0x8c, 0xb9, 0xb2, 0xeb, 0xff, 0xa1, 0x1e, 0x26, 0x44,
	0x1a, 0xb0, 0x71, 0x10, 0x44, 0xf2, 0x4a, 0xd3, 0x62, 0xfc, 0x62, 0xdf, 0x8d, 0x74, 0x5e, 0x6d,
	0xe2, 0x74, 0x33, 0xc7, 0xa4, 0x6e, 0x6d, 0x76, 0xd9, 0x76, 0x05, 0x0d, 0xbd, 0x89, 0xf5, 0xff,
	0x4a, 0xb7, 0x14, 0x21, 0x5f, 0xc1, 0xc3, 0xf7, 0xb4, 0x6f, 0x38, 0x8e, 0x86, 0x22, 0xf0, 0x5c,
	0x41, 0x23, 0xdc, 0xad, 0x8d, 0x02, 0x37, 0xb1, 0x90, 0x43, 0x58, 0x8d, 0xed, 0xaf, 0xdd, 0x11,
	0x59, 0x9f, 0x62, 0x59, 0x7d, 0x90, 0x96, 0xd5, 0x1c, 0x87, 0x33, 0x25, 0x22, 0xeb, 0xb8, 0x3e,
	0xd9, 0x92, 0x98, 0x7e, 0xaa, 0xea, 0x78, 0x0e, 0x26, 0x3b, 0x70, 0x1f, 0xef, 0x3d, 0xbd, 0x76,
	0xb7, 0x49, 0xb9, 0x08, 0x3e, 0xa0, 0x32, 0xa8, 0xee, 0x0f, 0x50, 0xe2, 0xba, 0x61, 0x9b, 0xa5,
	0x67, 0x85, 0x5e, 0x57, 0x59, 0x5d, 0x78, 0x67, 0x5d, 0xc1, 0x83, 0x70, 0xa0, 0x8b, 0xb7, 0x09,
	0xa1, 0xff, 0xe9, 0x68, 0xe8, 0x7a, 0xf4, 0x7d, 0x90, 0xd4, 0x70, 0x13, 0x92, 0xd1, 0xdb, 0xcd,
	0x14, 0xf1, 0x98, 0xb4, 0x7f, 0x57, 0x80, 0x65, 0xf9, 0xd1, 0x0e, 0x22, 0xa1, 0x9a, 0xab, 0x1a,
	0x94, 0x93, 0x12, 0xa6, 0x4f, 0x8a, 0xa4, 0x7e, 0x3d, 0x85, 0x95, 0x23, 0x26, 0x0c, 0xa5, 0x71,
	0xb1, 0xb2, 0x93, 0x43, 0xb1, 0xab, 0x93, 0xe7, 0xb4, 0x8f, 0xf1, 0x56, 0x52, 0x3e, 0x4d, 0x11,
	0xa9, 0x71, 0x4a, 0x75, 0xf1, 0xe0, 0x28, 0x3b, 0x26, 0x64, 0xbf, 0x52, 0x5a, 0x48, 0xb5, 0xc8,
	0x8f, 0x61, 0x5e, 0x7e, 0xc7, 0x3d, 0x95, 0xd1, 0xab, 0x65, 0x34, 0x77, 0x14, 0x97, 0x7d, 0x00,
	0x65, 0x79, 0xee, 0xe2, 0x65, 0x69, 0x67, 0xea, 0xba, 0xf1, 0x68, 0xe6, 0x45, 0x6b, 0xea, 0xca,
	0x61, 0xff, 0x14, 0xee, 0xa9, 0x82, 0x36, 0xe6, 0xb4, 0xc3, 0x59, 0x9f, 0xf2, 0xf8, 0x28, 0x55,
	0xc9, 0xd2, 0xa7, 0x5c, 0x07, 0x9c, 0x7e, 0xd2, 0xc8, 0x82, 0xf6, 0xaf, 0xd5, 0x9d, 0x1c, 0x33,
	0x28, 0x69, 0xd4, 0x0b, 0x69, 0xa3, 0x2e, 0xcf, 0x16, 0x75, 0x82, 0x69, 0x87, 0x69, 0x6a, 0xe6,
	0xd3, 0x43, 0xe9, 0x3f, 0x7b, 0x7a, 0xb0, 0xff, 0x5c, 0x88, 0x0b, 0xb6, 0x6c, 0xfc, 0xc9, 0x36,
	0x94, 0x7b, 0xde, 0x08, 0x8d, 0xa0, 0x6d, 0x4a, 0x52, 0xab, 0xc4, 0x4a, 0x3b, 0x09, 0x0f, 0xd9,
	0x85, 0xca, 0xb1, 0x10, 0x5a, 0xa0, 0x78, 0xab, 0x86, 0x24, 0x15, 0x20, 0x5f, 0x42, 0xf5, 0x68,
	0xc8, 0xfa, 0xee, 0x50, 0x77, 0x34, 0x25, 0xf4, 0xc3, 0xbd, 0x74, 0x02, 0x73, 0xd4, 0xc9, 0xf0,
	0xda, 0xbb, 0x59, 0x59, 0xf2, 0x19, 0xac, 0x1d, 0xd0, 0xfe, 0x78, 0xa0, 0x36, 0xa7, 0xcf, 0xe6,
	0x02, 0x1e, 0xc2, 0xd3, 0x03, 0xf6, 0xef, 0x8b, 0x00, 0xbd, 0x66, 0x47, 0xa7, 0xa7, 0x8c, 0xba,
	0x93, 0xb0, 0xcf, 0xc6, 0xa1, 0x6f, 0x38, 0xc3, 0x84, 0x8c, 0xb6, 0x4b, 0xdd, 0xca, 0x6f, 0xd9,
	0x76, 0x49, 0xb5, 0xd0, 0x66, 0x5f, 0x8f, 0x45, 0x3a, 0xbf, 0x72, 0xda, 0xf4, 0x80, 0x2c, 0x24,
	0x08, 0xe6, 0x5a, 0xa7, 0x65, 0x27, 0x0f, 0xe7, 0x38, 0x31, 0x7f, 0x55, 0x07, 0x95, 0x87, 0x65,
	0xd6, 0x76, 0x28, 0xe5, 0x46, 0x73, 0x9f, 0xd0, 0xf1, 0x18, 0x2e, 0xb4, 0xa8, 0x1a, 0xdf, 0x98,
	0xb6, 0xf7, 0x61, 0x25, 0xb5, 0x10, 0x66, 0x5b, 0x1d, 0xca, 0x9a, 0x8c, 0x13, 0x6e, 0x23, 0x13,
	0x1c, 0x71, 0xb1, 0x4b, 0xb8, 0xec, 0xbf, 0x16, 0x70, 0x92, 0x53, 0x9a, 0x5e, 0xb0, 0x66, 0x1a,
	0xa4, 0x70, 0x9d, 0x41, 0xf2, 0xdc, 0xb8, 0x0b, 0x95, 0x15, 0xd3, 0x03, 0xb3, 0xcc, 0x57, 0xba,
	0xb5, 0xf9, 0xe6, 0x66, 0x9a, 0xaf, 0xf1, 0x1d, 0xac, 0xbc, 0xa7, 0xfd, 0x08, 0x5f, 0x81, 0x54,
	0xca, 0xb6, 0x61, 0x39, 0x79, 0x17, 0xc2, 0x9a, 0x55, 0x4b, 0xad, 0x90, 0x7f, 0x5a, 0xaa, 0x3d,
	0x9c, 0x39, 0xa6, 0x2a, 0xc9, 0x56, 0xa1, 0x5e, 0x68, 0xf4, 0xe1, 0xee, 0x7e, 0x70, 0x80, 0x75,
	0x3d, 0x60, 0xa1, 0x3b, 0x54, 0xa5, 0x87, 0x72, 0x72, 0x02, 0x55, 0xf5, 0xbd, 0x1f, 0xe0, 0x2a,
	0xc6, 0x89, 0x94, 0x7b, 0x6b, 0xaa, 0xd5, 0x66, 0x0d, 0x19, 0x6b, 0xfc, 0x02, 0x56, 0x0f, 0xd8,
	0x65, 0x38, 0x64, 0xae, 0x9f, 0x4c, 0x7f, 0x18, 0x3f, 0x1d, 0xe1, 0xe4, 0xd7, 0xdd, 0x72, 0x6b,
	0x37, 0x16, 0xc5, 0x7a, 0xa1, 0xf1, 0xf7, 0x05, 0xb8, 0x73, 0xdc, 0x38, 0x42, 0xcb, 0xc4, 0x5d,
	0xfb, 0x29, 0x54, 0xcd, 0x07, 0x65, 0xf2, 0xd8, 0xb8, 0x15, 0x4d, 0xbf, 0x3f, 0xd7, 0x9e, 0x5c,
	0x37, 0xac, 0x6f, 0x72, 0xaf, 0x61, 0xc9, 0x78, 0x39, 0x26, 0x86, 0x46, 0xd3, 0x4f, 0xd0, 0xb5,
	0xc7, 0xd7, 0x8c, 0x26, 0x73, 0x55, 0xcd, 0xe7, 0x63, 0x53, 0xb5, 0x19, 0xcf, 0xca, 0xa6, 0xf7,
	0xa6, 0xde, 0xa2, 0x65, 0x1c, 0x64, 0x52, 0x9f, 0xfc, 0x93, 0x9a, 0x70, 0xf3, 0x6c, 0x3f, 0x82,
	0xca, 0x11, 0x15, 0x7a, 0x8f, 0xd5, 0x6d, 0xfd, 0x70, 0xff, 0x0d, 0x0b, 0xfc, 0x5a, 0xe6, 0x56,
	0x89, 0xe3, 0x2f, 0x60, 0xf9, 0x88, 0x8a, 0x37, 0x21, 0xbb, 0x0c, 0xf1, 0x64, 0xcb, 0x09, 0x90,
	0xe9, 0x73, 0x50, 0x3a, 0x25, 0x8e, 0x0d, 0x54, 0xf6, 0xe1, 0x6c, 0xc7, 0xde, 0xc2, 0xeb, 0x32,
	0xa4, 0xfe, 0x4b, 0xe1, 0x23, 0xcf, 0x0f, 0x3c, 0xdb, 0x8f, 0x7b, 0xa7, 0x6d, 0x62, 0x14, 0x7e,
	0xf3, 0xed, 0xa4, 0x76, 0x7f, 0x0a, 0xd7, 0x36, 0xdb, 0x81, 0x79, 0x04, 0xfe, 0x75, 0xc9, 0x3d,
	0xb8, 0x93, 0x3b, 0xc3, 0xc9, 0x66, 0xde, 0xca, 0xf9, 0xe3, 0xbd, 0x96, 0x31, 0x32, 0xd9, 0x05,
	0x38, 0xa2, 0x42, 0x57, 0x37, 0x62, 0x65, 0x2a, 0xa1, 0x51, 0xf0, 0x6a, 0x33, 0x6b, 0x24, 0xd9,
	0x81, 0x15, 0x25, 0x1d, 0xd7, 0xca, 0x9c, 0x0b, 0xad, 0x59, 0x52, 0xd2, 0x91, 0xfb, 0xaf, 0xe1,
	0x93, 0x90, 0x0a, 0xf3, 0x4f, 0x1f, 0xfd, 0x37, 0x90, 0x3b, 0x0a, 0xa2, 0x44, 0xea, 0xdb, 0x4f,
	0x6e, 0xf1, 0xd7, 0x52, 0x7f, 0x01, 0xff, 0x18, 0xfa, 0xfc, 0x1f, 0x01, 0x00, 0x00, 0xff, 0xff,
	0xc2, 0xd2, 0x9f, 0x80, 0x8f, 0x1a, 0x00, 0x00,
}
